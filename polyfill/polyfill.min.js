!function() {
    "use strict";
    function t(t) {
        return W.isArray(t) ? t : W.from(t);
    }
    function e(t) {
        if (W.isArray(t)) {
            for (var e = 0, r = W(t.length); e < t.length; e++) r[e] = t[e];
            return r;
        }
        return W.from(t);
    }
    function r(t, e) {
        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !e || "object" != typeof e && "function" != typeof e ? t : e;
    }
    function n(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }
    function o(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
    }
    function i(t, e) {
        return e = {
            exports: {}
        }, t(e, e.exports), e.exports;
    }
    function a(t) {
        return "function" == typeof t;
    }
    function u(t, e, r) {
        var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, o = t.length, i = t[K] ? t[K]() : t;
        if (0 <= o) {
            for (var u = n; u < o; u += 1) if (e.call(r, t[u], u, t)) return;
        } else if (a(i.next)) for (var s = 0; s < Number.MAX_SAFE_INTEGER; ) {
            var c = i.next(), f = c.value, l = c.done;
            if (l || n <= s && e.call(r, f, s, t)) return;
            s += 1;
        } else {
            var h = n, d = !0, y = !1, v = void 0;
            try {
                for (var p, w = t[Symbol.iterator](); !(d = (p = w.next()).done); d = !0) {
                    var m = p.value;
                    if (e.call(r, m, h, t)) return;
                    h += 1;
                }
            } catch (t) {
                y = !0, v = t;
            } finally {
                try {
                    !d && w.return && w.return();
                } finally {
                    if (y) throw v;
                }
            }
        }
    }
    function s(t) {
        return "string" == typeof t;
    }
    function c() {
        var t = this, e = this.length, r = 0;
        return {
            next: function() {
                return {
                    value: t[r],
                    done: e <= r++
                };
            }
        };
    }
    function f(t) {
        for (var e = arguments.length, r = W(e > 1 ? e - 1 : 0), n = 1; n < e; n++) r[n - 1] = arguments[n];
        return $.apply(t, r);
    }
    function l(t) {
        return t;
    }
    function h(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : l, r = arguments[2], n = [];
        return u(t, function(o, i) {
            f(n, e.call(r, o, i, t));
        }), n;
    }
    function d(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ",";
        return h(t).join(e);
    }
    function y(t) {
        for (var e = tt(t, 10), r = [], n = 0; n < e; n += 1) f(r, this);
        return d(r, "");
    }
    // let firstImmediate = true;
    // let immediateCount = 0;
    // const tasks = {};
    // const suffix = `_setImmediate${window.immediateId}`;
    // function setImmediatePostMessage(fn) {
    // 	if (firstImmediate) {
    // 		firstImmediate = false;
    // 		addEventListner(window, 'message', function ({data}) {
    // 			if (data.split) {
    // 				const [key] = data.split(suffix);
    // 				const task = tasks[key];
    // 				if (task) {
    // 					task();
    // 				}
    // 				delete tasks[key];
    // 			}
    // 		});
    // 	}
    // 	immediateCount += 1;
    // 	postMessage(`${immediateCount}${suffix}`, '*');
    // 	tasks[immediateCount] = fn;
    // 	return immediateCount;
    // }
    function v(t) {
        return et(t);
    }
    function p(t, e) {
        var r = 1;
        t(function() {
            4 == (r *= 2) && e();
        }), r += 1;
    }
    function w(t) {
        return t && a(t.then) && a(t.catch);
    }
    function m(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : l, r = arguments[2], n = void 0;
        return u(t, function(o, i) {
            if (e.call(r, o, i, t)) return n = o, !0;
        }), n;
    }
    function g(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : l, r = arguments[2], n = -1;
        return u(t, function(o, i) {
            if (e.call(r, o, i, t)) return n = i, !0;
        }), n;
    }
    function b(t) {
        for (var e = arguments.length, r = W(e > 1 ? e - 1 : 0), n = 1; n < e; n++) r[n - 1] = arguments[n];
        return t.splice.apply(t, r);
    }
    function k() {
        return this.entries();
    }
    function x() {
        var t = this, e = this.length, r = 0;
        return {
            next: function() {
                return {
                    value: t[r],
                    done: e <= r++
                };
            }
        };
    }
    function _() {
        var t = this, e = this.length, r = 0;
        return {
            next: function() {
                return {
                    value: t[r],
                    done: e <= r++
                };
            }
        };
    }
    function O() {
        var t = this, e = this.length, r = 0;
        return {
            next: function() {
                return {
                    value: t[r],
                    done: e <= r++
                };
            }
        };
    }
    function j(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : l, r = arguments[2], n = [];
        return u(t, function(t, o, i) {
            e.call(r, t, o, i) && f(n, t);
        }), n;
    }
    function A(t, e, r) {
        for (var n in t) if (t.hasOwnProperty(n) && e.call(r, t[n], n, t)) return;
    }
    function E(t) {
        return ("" + t).toLowerCase();
    }
    function L(t, e) {
        return t instanceof e;
    }
    function S(t) {
        return 0 <= g(Nt, function(e) {
            return L(t, e);
        });
    }
    /* eslint-disable no-bitwise */
    function T(t, e, r) {
        for (var n = Ct[r], o = 0, i = 0; 0 < r--; ) {
            var a = 0 === r ? n : Gt, u = Ht * i++;
            o |= (t[e + r] & a) << u;
        }
        return o;
    }
    /* eslint-enable no-bitwise */
    function P(t) {
        for (var r = new Lt(t), n = [], o = 0; o < r.length; o++) {
            var i = r[o], a = void 0;
            a = i < 128 ? 1 : i < 224 ? 2 : i < 240 ? 3 : i < 248 ? 4 : i < 252 ? 5 : 6, n.push(T(r, o, a)), 
            o += a - 1;
        }
        for (var u = [], s = 4096; 0 < n.length; ) u.push(qt.apply(void 0, e(n.splice(0, s))));
        return u.join("");
    }
    function B(t, e) {
        var r = new Yt(), n = new Promise(function(n, o) {
            switch (r.onload = function() {
                n(r.result);
            }, r.onerror = function() {
                o(r.error);
            }, e) {
              case "ArrayBuffer":
                r.readAsArrayBuffer(t);
                break;

              case "BinaryString":
                r.readAsBinaryString(t);
                break;

              case "DataURL":
                r.readAsDataURL(t);
                break;

              default:
                r.readAsText(t);
            }
        });
        return n.reader = r, n;
    }
    function F(t) {
        return t.trim();
    }
    function R(e) {
        var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Jt();
        return u(F(e).split("&"), function(e) {
            if (e) {
                var n = e.split("="), o = t(n), i = o[0], a = o.slice(1);
                i = Vt(i.replace(/\+/g, " ")), a = Vt(a.join("=").replace(/\+/g, " ")), r.append(i, a);
            }
        }), r;
    }
    function U(t) {
        if (t.slice) return t.slice(0);
        var e = new Lt(t.byteLength);
        return e.set(new Lt(t)), e.buffer;
    }
    function I(e) {
        var r = new re();
        return e.replace(/\r?\n[\t ]+/, " ").split(/\r?\n/).forEach(function(e) {
            var n = e.split(":"), o = t(n), i = o[0], a = o.slice(1);
            i && r.append(F(i), F(a.join(":")));
        }), r;
    }
    function N(t) {
        return void 0 === t;
    }
    function D(t, e) {
        return new Xt(function(r, n) {
            var o = new Wt(t, e), i = new ne();
            i.onload = function() {
                var t = {
                    status: i.status,
                    statusText: i.statusText,
                    headers: I(i.getAllResponseHeaders() || "")
                };
                t.url = "responseURL" in i ? i.responseURL : t.headers.get("X-Request-URL");
                var e = "response" in i ? i.response : i.responseText;
                r(new ee(e, t));
            }, i.onerror = function() {
                n(new TypeError("Network request failed"));
            }, i.ontimeout = function() {
                n(new TypeError("Network request failed"));
            }, i.open(o.method, o.url, !0), "include" === o.credentials && (i.withCredentials = !0), 
            i.responseType = "blob", u(o.headers, function(t) {
                var e = G(t, 2), r = e[0], n = e[1];
                i.setRequestHeader(r, n);
            }), i.send(N(o.bodyInit) ? null : o.bodyInit);
        });
    }
    var q = function t(e, r, n) {
        null === e && (e = Function.prototype);
        var o = Object.getOwnPropertyDescriptor(e, r);
        if (void 0 === o) {
            var i = Object.getPrototypeOf(e);
            return null === i ? void 0 : t(i, r, n);
        }
        if ("value" in o) return o.value;
        var a = o.get;
        if (void 0 !== a) return a.call(n);
    }, G = function() {
        function t(t, e) {
            var r = [], n = !0, o = !1, i = void 0;
            try {
                for (var a, u = t[Symbol.iterator](); !(n = (a = u.next()).done) && (r.push(a.value), 
                !e || r.length !== e); n = !0) ;
            } catch (t) {
                o = !0, i = t;
            } finally {
                try {
                    !n && u.return && u.return();
                } finally {
                    if (o) throw i;
                }
            }
            return r;
        }
        return function(e, r) {
            if (W.isArray(e)) return e;
            if (Symbol.iterator in Object(e)) return t(e, r);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }(), C = function() {
        function t(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, n.key, n);
            }
        }
        return function(e, r, n) {
            return r && t(e.prototype, r), n && t(e, n), e;
        };
    }(), H = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t;
    } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, M = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, z = (i(function(t) {
        /**
  * Copyright (c) 2014, Facebook, Inc.
  * All rights reserved.
  *
  * This source code is licensed under the BSD-style license found in the
  * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
  * additional grant of patent rights can be found in the PATENTS file in
  * the same directory.
  */
        !function(e) {
            function r(t, e, r, n) {
                // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
                var i = e && e.prototype instanceof o ? e : o, a = Object.create(i.prototype), u = new d(n || []);
                // The ._invoke method unifies the implementations of the .next,
                // .throw, and .return methods.
                return a._invoke = c(t, r, u), a;
            }
            // Try/catch helper to minimize deoptimizations. Returns a completion
            // record like context.tryEntries[i].completion. This interface could
            // have been (and was previously) designed to take a closure to be
            // invoked without arguments, but in all the cases we care about we
            // already have an existing method we want to call, so there's no need
            // to create a new function object. We can even get away with assuming
            // the method takes exactly one argument, since that happens to be true
            // in every case, so we don't have to touch the arguments object. The
            // only additional allocation required is the completion record, which
            // has a stable shape and so hopefully should be cheap to allocate.
            function n(t, e, r) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, r)
                    };
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    };
                }
            }
            // Dummy constructor functions that we use as the .constructor and
            // .constructor.prototype properties for functions that return Generator
            // objects. For full spec compliance, you may wish to configure your
            // minifier not to mangle the names of these two functions.
            function o() {}
            function i() {}
            function a() {}
            // Helper for defining the .next, .throw, and .return methods of the
            // Iterator interface in terms of a single ._invoke method.
            function u(t) {
                [ "next", "throw", "return" ].forEach(function(e) {
                    t[e] = function(t) {
                        return this._invoke(e, t);
                    };
                });
            }
            function s(t) {
                function r(e, o, i, a) {
                    var u = n(t[e], t, o);
                    if ("throw" !== u.type) {
                        var s = u.arg, c = s.value;
                        return c && "object" === (void 0 === c ? "undefined" : H(c)) && m.call(c, "__await") ? Promise.resolve(c.__await).then(function(t) {
                            r("next", t, i, a);
                        }, function(t) {
                            r("throw", t, i, a);
                        }) : Promise.resolve(c).then(function(t) {
                            // When a yielded Promise is resolved, its final value becomes
                            // the .value of the Promise<{value,done}> result for the
                            // current iteration. If the Promise is rejected, however, the
                            // result for this iteration will be rejected with the same
                            // reason. Note that rejections of yielded Promises are not
                            // thrown back into the generator function, as is the case
                            // when an awaited Promise is rejected. This difference in
                            // behavior between yield and await is important, because it
                            // allows the consumer to decide what to do with the yielded
                            // rejection (swallow it and continue, manually .throw it back
                            // into the generator, abandon iteration, whatever). With
                            // await, by contrast, there is no opportunity to examine the
                            // rejection reason outside the generator function, so the
                            // only option is to throw it from the await expression, and
                            // let the generator function handle the exception.
                            s.value = t, i(s);
                        }, a);
                    }
                    a(u.arg);
                }
                function o(t, e) {
                    function n() {
                        return new Promise(function(n, o) {
                            r(t, e, n, o);
                        });
                    }
                    // If enqueue has been called before, then we want to wait until
                    // all previous Promises have been resolved before calling invoke,
                    // so that results are always delivered in the correct order. If
                    // enqueue has not been called before, then it is important to
                    // call invoke immediately, without waiting on a callback to fire,
                    // so that the async generator function has the opportunity to do
                    // any necessary setup in a predictable way. This predictability
                    // is why the Promise constructor synchronously invokes its
                    // executor callback, and why async functions synchronously
                    // execute code before the first await. Since we implement simple
                    // async functions in terms of async generators, it is especially
                    // important to get this right, even though it requires care.
                    // Avoid propagating failures to Promises returned by later
                    // invocations of the iterator.
                    return i = i ? i.then(n, n) : n();
                }
                "object" === H(e.process) && e.process.domain && (r = e.process.domain.bind(r));
                var i;
                // Define the unified helper method that is used to implement .next,
                // .throw, and .return (see defineIteratorMethods).
                this._invoke = o;
            }
            function c(t, e, r) {
                var o = j;
                return function(i, a) {
                    if (o === E) throw new Error("Generator is already running");
                    if (o === L) {
                        if ("throw" === i) throw a;
                        // Be forgiving, per 25.3.3.3.3 of the spec:
                        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                        return v();
                    }
                    for (r.method = i, r.arg = a; ;) {
                        var u = r.delegate;
                        if (u) {
                            var s = f(u, r);
                            if (s) {
                                if (s === S) continue;
                                return s;
                            }
                        }
                        if ("next" === r.method) // Setting context._sent for legacy support of Babel's
                        // function.sent implementation.
                        r.sent = r._sent = r.arg; else if ("throw" === r.method) {
                            if (o === j) throw o = L, r.arg;
                            r.dispatchException(r.arg);
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        o = E;
                        var c = n(t, e, r);
                        if ("normal" === c.type) {
                            if (// If an exception is thrown from innerFn, we leave state ===
                            // GenStateExecuting and loop back for another invocation.
                            o = r.done ? L : A, c.arg === S) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            };
                        }
                        "throw" === c.type && (o = L, // Dispatch the exception by looping back around to the
                        // context.dispatchException(context.arg) call above.
                        r.method = "throw", r.arg = c.arg);
                    }
                };
            }
            // Call delegate.iterator[context.method](context.arg) and handle the
            // result, either by returning a { value, done } result from the
            // delegate iterator, or by modifying context.method and context.arg,
            // setting context.delegate to null, and returning the ContinueSentinel.
            function f(t, e) {
                var r = t.iterator[e.method];
                if (r === p) {
                    if (// A .throw or .return when the delegate iterator has no .throw
                    // method always terminates the yield* loop.
                    e.delegate = null, "throw" === e.method) {
                        if (t.iterator.return && (// If the delegate iterator has a return method, give it a
                        // chance to clean up.
                        e.method = "return", e.arg = p, f(t, e), "throw" === e.method)) // If maybeInvokeDelegate(context) changed context.method from
                        // "return" to "throw", let that override the TypeError below.
                        return S;
                        e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method");
                    }
                    return S;
                }
                var o = n(r, t.iterator, e.arg);
                if ("throw" === o.type) return e.method = "throw", e.arg = o.arg, e.delegate = null, 
                S;
                var i = o.arg;
                // Assign the result of the finished delegate to the temporary
                // variable specified by delegate.resultName (see delegateYield).
                // Resume execution at the desired location (see delegateYield).
                // If context.method was "throw" but the delegate handled the
                // exception, let the outer generator proceed normally. If
                // context.method was "next", forget context.arg since it has been
                // "consumed" by the delegate iterator. If context.method was
                // "return", allow the original .return call to continue in the
                // outer generator.
                // The delegate iterator is finished, so forget it and continue with
                // the outer generator.
                return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", 
                e.arg = p), e.delegate = null, S) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), 
                e.delegate = null, S);
            }
            function l(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), 
                this.tryEntries.push(e);
            }
            function h(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e;
            }
            function d(t) {
                // The root entry object (effectively a try statement without a catch
                // or a finally block) gives us a place to store values thrown from
                // locations where there is no enclosing try statement.
                this.tryEntries = [ {
                    tryLoc: "root"
                } ], t.forEach(l, this), this.reset(!0);
            }
            function y(t) {
                if (t) {
                    var e = t[b];
                    if (e) return e.call(t);
                    if ("function" == typeof t.next) return t;
                    if (!isNaN(t.length)) {
                        var r = -1, n = function e() {
                            for (;++r < t.length; ) if (m.call(t, r)) return e.value = t[r], e.done = !1, e;
                            return e.value = p, e.done = !0, e;
                        };
                        return n.next = n;
                    }
                }
                // Return an iterator with no values.
                return {
                    next: v
                };
            }
            function v() {
                return {
                    value: p,
                    done: !0
                };
            }
            var p, w = Object.prototype, m = w.hasOwnProperty, g = "function" == typeof Symbol ? Symbol : {}, b = g.iterator || "@@iterator", k = g.asyncIterator || "@@asyncIterator", x = g.toStringTag || "@@toStringTag", _ = !0, O = e.regeneratorRuntime;
            if (O) // Don't bother evaluating the rest of this file if the runtime was
            // already defined globally.
            // If regeneratorRuntime is defined globally and we're in a module,
            // make the exports object identical to regeneratorRuntime.
            return void (_ && (t.exports = O));
            // Define the runtime globally (as expected by generated code) as either
            // module.exports (if we're in a module) or a new, empty object.
            O = e.regeneratorRuntime = _ ? t.exports : {}, O.wrap = r;
            var j = "suspendedStart", A = "suspendedYield", E = "executing", L = "completed", S = {}, T = {};
            T[b] = function() {
                return this;
            };
            var P = Object.getPrototypeOf, B = P && P(P(y([])));
            B && B !== w && m.call(B, b) && (// This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            T = B);
            var F = a.prototype = o.prototype = Object.create(T);
            i.prototype = F.constructor = a, a.constructor = i, a[x] = i.displayName = "GeneratorFunction", 
            O.isGeneratorFunction = function(t) {
                var e = "function" == typeof t && t.constructor;
                // For the native GeneratorFunction constructor, the best we can
                // do is to check its .name property.
                return !!e && (e === i || "GeneratorFunction" === (e.displayName || e.name));
            }, O.mark = function(t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, a) : (t.__proto__ = a, x in t || (t[x] = "GeneratorFunction")), 
                t.prototype = Object.create(F), t;
            }, // Within the body of any async function, `await x` is transformed to
            // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
            // `hasOwn.call(value, "__await")` to determine if the yielded value is
            // meant to be awaited.
            O.awrap = function(t) {
                return {
                    __await: t
                };
            }, u(s.prototype), s.prototype[k] = function() {
                return this;
            }, O.AsyncIterator = s, // Note that simple async functions are implemented on top of
            // AsyncIterator objects; they just return a Promise for the value of
            // the final result produced by the iterator.
            O.async = function(t, e, n, o) {
                var i = new s(r(t, e, n, o));
                return O.isGeneratorFunction(e) ? i : i.next().then(function(t) {
                    return t.done ? t.value : i.next();
                });
            }, // Define Generator.prototype.{next,throw,return} in terms of the
            // unified ._invoke helper method.
            u(F), F[x] = "Generator", // A Generator should always return itself as the iterator object when the
            // @@iterator function is called on it. Some browsers' implementations of the
            // iterator prototype chain incorrectly implement this, causing the Generator
            // object to not be returned from this call. This ensures that doesn't happen.
            // See https://github.com/facebook/regenerator/issues/274 for more details.
            F[b] = function() {
                return this;
            }, F.toString = function() {
                return "[object Generator]";
            }, O.keys = function(t) {
                var e = [];
                for (var r in t) e.push(r);
                // Rather than returning an object with a next method, we keep
                // things simple and return the next function itself.
                return e.reverse(), function r() {
                    for (;e.length; ) {
                        var n = e.pop();
                        if (n in t) return r.value = n, r.done = !1, r;
                    }
                    // To avoid creating an additional object, we just hang the .value
                    // and .done properties off the next function object itself. This
                    // also ensures that the minifier will not anonymize the function.
                    return r.done = !0, r;
                };
            }, O.values = y, d.prototype = {
                constructor: d,
                reset: function(t) {
                    if (this.prev = 0, this.next = 0, // Resetting context._sent for legacy support of Babel's
                    // function.sent implementation.
                    this.sent = this._sent = p, this.done = !1, this.delegate = null, this.method = "next", 
                    this.arg = p, this.tryEntries.forEach(h), !t) for (var e in this) // Not sure about the optimal order of these conditions:
                    "t" === e.charAt(0) && m.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = p);
                },
                stop: function() {
                    this.done = !0;
                    var t = this.tryEntries[0], e = t.completion;
                    if ("throw" === e.type) throw e.arg;
                    return this.rval;
                },
                dispatchException: function(t) {
                    function e(e, n) {
                        // If the dispatched exception was caught by a catch block,
                        // then let that catch block handle the exception normally.
                        return i.type = "throw", i.arg = t, r.next = e, n && (r.method = "next", r.arg = p), 
                        !!n;
                    }
                    if (this.done) throw t;
                    for (var r = this, n = this.tryEntries.length - 1; n >= 0; --n) {
                        var o = this.tryEntries[n], i = o.completion;
                        if ("root" === o.tryLoc) // Exception thrown outside of any try block that could handle
                        // it, so set the completion value of the entire function to
                        // throw the exception.
                        return e("end");
                        if (o.tryLoc <= this.prev) {
                            var a = m.call(o, "catchLoc"), u = m.call(o, "finallyLoc");
                            if (a && u) {
                                if (this.prev < o.catchLoc) return e(o.catchLoc, !0);
                                if (this.prev < o.finallyLoc) return e(o.finallyLoc);
                            } else if (a) {
                                if (this.prev < o.catchLoc) return e(o.catchLoc, !0);
                            } else {
                                if (!u) throw new Error("try statement without catch or finally");
                                if (this.prev < o.finallyLoc) return e(o.finallyLoc);
                            }
                        }
                    }
                },
                abrupt: function(t, e) {
                    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                        var n = this.tryEntries[r];
                        if (n.tryLoc <= this.prev && m.call(n, "finallyLoc") && this.prev < n.finallyLoc) {
                            var o = n;
                            break;
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (// Ignore the finally entry if control is not jumping to a
                    // location outside the try/catch block.
                    o = null);
                    var i = o ? o.completion : {};
                    return i.type = t, i.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, 
                    S) : this.complete(i);
                },
                complete: function(t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, 
                    this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), 
                    S;
                },
                finish: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var r = this.tryEntries[e];
                        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), h(r), S;
                    }
                },
                catch: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var r = this.tryEntries[e];
                        if (r.tryLoc === t) {
                            var n = r.completion;
                            if ("throw" === n.type) {
                                var o = n.arg;
                                h(r);
                            }
                            return o;
                        }
                    }
                    // The context.catch method must only be called with a location
                    // argument that corresponds to a known catch block.
                    throw new Error("illegal catch attempt");
                },
                delegateYield: function(t, e, r) {
                    // Deliberately forget the last sent value so that we don't
                    // accidentally pass it on to the delegate.
                    return this.delegate = {
                        iterator: y(t),
                        resultName: e,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = p), S;
                }
            };
        }(// Among the various tricks for obtaining a reference to the global
        // object, this seems to be the most reliable technique that does not
        // use indirect eval (which violates Content Security Policy).
        "object" === (void 0 === M ? "undefined" : H(M)) ? M : "object" === ("undefined" == typeof window ? "undefined" : H(window)) ? window : "object" === ("undefined" == typeof self ? "undefined" : H(self)) ? self : M);
    }), window.window), K = Symbol.iterator, X = window.Date, Y = window.TypeError, J = 16, V = function() {
        function t() {
            o(this, t), this.seed = X.now(), this.registry = [];
        }
        return C(t, [ {
            key: "get",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X.now(), r = "Symbol(" + t + ")" + (this.seed + this.registry.length).toString(J);
                return this.registry.push([ r, "" + t + e ]), r;
            }
        }, {
            key: "for",
            value: function(t) {
                if (s(t)) {
                    for (var e = this.registry.length, r = 0; r < e; r += 1) {
                        var n = this.registry[r];
                        if (t === n[1]) return n[0];
                    }
                    return this.get(t, "");
                }
                throw new Y("Symbol.for was called with non-string: " + t);
            }
        }, {
            key: "keyFor",
            value: function(t) {
                for (var e = this.registry.length, r = 0; r < e; r += 1) {
                    var n = this.registry[r];
                    if (t === n[0]) return n[1];
                }
            }
        }, {
            key: "Symbol",
            get: function() {
                function t(t, e) {
                    Object.defineProperty(r, t, {
                        value: e
                    });
                }
                var e = this, r = function(t) {
                    return e.get(t);
                };
                return u([ "iterator", "match", "replace", "search", "split", "hasInstance", "isConcatSpreadable", "unscopables", "species", "toPrimitive", "toStringTag" ], function(e) {
                    t(e, r(e));
                }), t("for", function(t) {
                    return e.for(t);
                }), t("keyFor", function(t) {
                    return e.keyFor(t);
                }), r;
            }
        } ]), t;
    }(), Q = new V().Symbol;
    z.Symbol || (z.Symbol = Q);
    var W = window.Array, Z = W.prototype;
    Z[K] || (Z[K] = c);
    var $ = W.prototype.push;
    W.from || (W.from = h);
    var tt = window.parseInt;
    String.prototype.repeat || (String.prototype.repeat = y);
    var et = window.setTimeout;
    // import postMessage from '../postMessage';
    // import addEventListner from '../dom/addEventListener';
    z.immediateId || (z.immediateId = 0), z.immediateId += 1;
    var rt = z.setImmediate, nt = void 0;
    nt = v, et(function() {
        // if (postMessage) {
        // 	testImmediate(setImmediatePostMessage, function () {
        // 		if (setImmediateAvailable !== setImmediateNative) {
        // 			setImmediateAvailable = setImmediatePostMessage;
        // 		}
        // 	});
        // }
        rt && p(rt, function() {
            nt = rt;
        });
    });
    var ot = function(t) {
        return nt(t);
    }, it = 0, at = 1, ut = 2, st = 3, ct = function t() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        o(this, t), /* eslint-disable no-use-before-define */
        this.promise = new ft(l), /* eslint-enable no-use-before-define */
        this.onResolved = e, this.onRejected = r;
    }, ft = function() {
        function t(e) {
            o(this, t), this.deferreds = [], this.state = it, this.exec(e);
        }
        return C(t, [ {
            key: "is",
            value: function(t) {
                return this.state === t;
            }
        }, {
            key: "exec",
            value: function(t) {
                var e = this, r = !1, n = function(t) {
                    r || (r = !0, e.resolve(t));
                }, o = function(t) {
                    r || (r = !0, e.reject(t));
                };
                try {
                    t(n, o);
                } catch (t) {
                    o(t);
                }
            }
        }, {
            key: "resolve",
            value: function(t) {
                try {
                    if (t === this) throw new Y("A promise cannot be resolved with itself");
                    this.value = t, w(t) ? (this.state = st, this.exec(function(e, r) {
                        t.then(e, r);
                    })) : this.state = at, this.finish();
                } catch (t) {
                    this.reject(t);
                }
            }
        }, {
            key: "reject",
            value: function(t) {
                this.state = ut, this.value = t, this.finish();
            }
        }, {
            key: "finish",
            value: function() {
                var t = this;
                u(this.deferreds, function(e) {
                    t.handle(e);
                }), this.deferreds = null;
            }
        }, {
            key: "handle",
            value: function(t) {
                /* eslint-enable consistent-this */
                for (/* eslint-disable consistent-this */
                var e = this; e.is(st); ) e = e.value;
                if (e.is(it)) return void f(e.deferreds, t);
                ot(function() {
                    var r = t.promise, n = t.onResolved, o = void 0 === n ? null : n, i = t.onRejected, a = void 0 === i ? null : i, u = e.is(at), s = u ? o : a;
                    if (null === s) return void (u ? r.resolve(e.value) : r.reject(e.value));
                    var c = void 0;
                    try {
                        c = s(e.value);
                    } catch (t) {
                        return void r.reject(t);
                    }
                    r.resolve(c);
                });
            }
        }, {
            key: "catch",
            value: function(t) {
                return this.then(null, t);
            }
        }, {
            key: "then",
            value: function(t, e) {
                var r = new ct(t, e);
                return this.handle(r), r.promise;
            }
        } ], [ {
            key: "resolve",
            value: function(e) {
                return w(e) ? e : new t(function(t) {
                    t(e);
                });
            }
        }, {
            key: "reject",
            value: function(e) {
                return new t(function(t, r) {
                    r(e);
                });
            }
        }, {
            key: "race",
            value: function(e) {
                return new t(function(t, r) {
                    u(e, function(e) {
                        e.then(t, r);
                    });
                });
            }
        }, {
            key: "all",
            value: function(e) {
                return new t(function(t, r) {
                    function n(o, a) {
                        if (w(o)) return void o.then(function(t) {
                            n(t, a);
                        }, r);
                        e[a] = o, 0 === (i -= 1) && t(e);
                    }
                    var o = e.length;
                    if (0 === o) return void t([]);
                    var i = o;
                    u(e, function(t, e) {
                        n(t, e);
                    });
                });
            }
        } ]), t;
    }();
    z.Promise = z.Promise || ft;
    var lt = function() {
        function t(e) {
            var r = this;
            o(this, t), this.clear(), e && u(e, function(t) {
                var e = G(t, 2), n = e[0], o = e[1];
                r.set(n, o);
            });
        }
        return C(t, [ {
            key: "clear",
            value: function() {
                this.data = [];
            }
        }, {
            key: "indexOfKey",
            value: function(t) {
                return g(this.data, function(e) {
                    return G(e, 1)[0] === t;
                });
            }
        }, {
            key: "has",
            value: function(t) {
                return 0 <= this.indexOfKey(t);
            }
        }, {
            key: "set",
            value: function(t, e) {
                var r = this.indexOfKey(t);
                return 0 <= r ? this.data[r][1] = e : f(this.data, [ t, e ]), this;
            }
        }, {
            key: "get",
            value: function(t) {
                var e = m(this.data, function(e) {
                    return G(e, 1)[0] === t;
                });
                if (e) return e[1];
            }
        }, {
            key: "delete",
            value: function(t) {
                var e = this.indexOfKey(t);
                return 0 <= e && (b(this.data, e, 1), !0);
            }
        }, {
            key: "entries",
            value: function() {
                return this.data[Symbol.iterator]();
            }
        }, {
            key: "forEach",
            value: function(t, e) {
                u(this.data, t, e);
            }
        }, {
            key: "keys",
            value: function() {
                var t = this.entries();
                return {
                    next: function() {
                        var e = t.next(), r = e.value, n = e.done;
                        return {
                            value: r && r[0],
                            done: n
                        };
                    }
                };
            }
        }, {
            key: "values",
            value: function() {
                var t = this.entries();
                return {
                    next: function() {
                        var e = t.next(), r = e.value, n = e.done;
                        return {
                            value: r && r[1],
                            done: n
                        };
                    }
                };
            }
        }, {
            key: "size",
            get: function() {
                return this.data.length;
            }
        } ]), t;
    }(), ht = z.Map;
    ht && 1 === new ht([ [ 0, 0 ] ]).size && ht.prototype.forEach || (ht = lt), z.Map = ht;
    var dt = Map.prototype;
    dt[K] || (dt[K] = k);
    var yt = function() {
        function t(e) {
            var r = this;
            o(this, t), this.clear(), e && u(e, function(t) {
                r.add(t);
            });
        }
        return C(t, [ {
            key: "clear",
            value: function() {
                this.data = [];
            }
        }, {
            key: "indexOf",
            value: function(t) {
                return this.data.indexOf(t);
            }
        }, {
            key: "has",
            value: function(t) {
                return 0 <= this.indexOf(t);
            }
        }, {
            key: "add",
            value: function(t) {
                return this.has(t) || f(this.data, t), this;
            }
        }, {
            key: "delete",
            value: function(t) {
                var e = this.indexOf(t);
                return 0 <= e && b(this.data, e, 1), 0 <= e;
            }
        }, {
            key: "forEach",
            value: function(t, e) {
                var r = this;
                u(this.data, function(n) {
                    t.call(e, n, n, r);
                });
            }
        }, {
            key: "values",
            value: function() {
                return this.data[K]();
            }
        }, {
            key: K,
            value: function() {
                return this.values();
            }
        }, {
            key: "entries",
            value: function() {
                var t = this.values();
                return {
                    next: function() {
                        var e = t.next(), r = e.value, n = e.done;
                        return {
                            value: !n && [ r, r ],
                            done: n
                        };
                    }
                };
            }
        }, {
            key: "size",
            get: function() {
                return this.data.length;
            }
        } ]), t;
    }(), vt = z.Set;
    vt && 1 === new vt([ 0 ]).size && vt.prototype.forEach || (vt = yt), z.Set = vt;
    var pt = NodeList, wt = pt.prototype;
    wt[K] || (wt[K] = x);
    var mt = window.HTMLCollection, gt = mt.prototype;
    gt[K] || (gt[K] = _);
    var bt = NamedNodeMap, kt = bt.prototype;
    kt[K] || (kt[K] = O);
    var xt = function() {
        function t(e) {
            var r = this;
            o(this, t), this.clear(), e && h(e, function(t) {
                var e = G(t, 2), n = e[0], o = e[1];
                r.append(n, o);
            });
        }
        return C(t, [ {
            key: "clear",
            value: function() {
                this.data = [];
            }
        }, {
            key: "indexOf",
            value: function(t) {
                return g(this.data, function(e) {
                    return G(e, 1)[0] === t;
                });
            }
        }, {
            key: "has",
            value: function(t) {
                return 0 <= this.indexOf(t);
            }
        }, {
            key: "append",
            value: function(t, e) {
                f(this.data, [ t, e ]);
            }
        }, {
            key: "set",
            value: function(t, e) {
                var r = this.indexOf(t);
                r < 0 ? this.append(t, e) : this.data[r][1] = e;
            }
        }, {
            key: "delete",
            value: function(t) {
                this.data = j(this.data, function(e) {
                    return G(e, 1)[0] !== t;
                });
            }
        }, {
            key: "get",
            value: function(t) {
                var e = m(this.data, function(e) {
                    return G(e, 1)[0] === t;
                });
                return e ? e[1] : null;
            }
        }, {
            key: "getAll",
            value: function(t) {
                var e = [];
                return u(this.data, function(r) {
                    var n = G(r, 2), o = n[0], i = n[1];
                    o === t && f(e, i);
                }), e;
            }
        }, {
            key: "toString",
            value: function() {
                return h(this.data, function(t) {
                    var e = G(t, 2), r = e[0], n = e[1];
                    return r + ":" + (void 0 === n ? "" : n);
                }).join(",");
            }
        }, {
            key: "entries",
            value: function() {
                return this.data[K]();
            }
        }, {
            key: "values",
            value: function() {
                var t = this.entries();
                return {
                    next: function() {
                        var e = t.next(), r = e.value, n = e.done;
                        return {
                            value: r && r[1],
                            done: n
                        };
                    }
                };
            }
        }, {
            key: K,
            value: function() {
                return this.entries();
            }
        } ]), t;
    }(), _t = "&", Ot = "=", jt = function(t) {
        function e(t) {
            return o(this, e), r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t ? h(t.replace(/^\?/, "").split(_t), function(t) {
                return t.split(Ot);
            }) : null));
        }
        return n(e, t), C(e, [ {
            key: "toString",
            value: function() {
                return h(this.data, function(t) {
                    var e = G(t, 2), r = e[0], n = e[1];
                    return r + "=" + (void 0 === n ? "" : n);
                }).join("&");
            }
        } ]), e;
    }(xt), At = z.URLSearchParams;
    At && new At("?a=b").has("a") || (z.URLSearchParams = jt);
    var Et = function(t) {
        function e(t) {
            o(this, e);
            var n = [];
            return t && A(t, function(t, e) {
                f(n, [ e, t ]);
            }), r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n));
        }
        return n(e, t), C(e, [ {
            key: "indexOf",
            value: function(t) {
                return q(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "indexOf", this).call(this, E(t));
            }
        }, {
            key: "has",
            value: function(t) {
                return q(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "has", this).call(this, E(t));
            }
        }, {
            key: "append",
            value: function(t, r) {
                return q(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "append", this).call(this, E(t), r);
            }
        }, {
            key: "set",
            value: function(t, r) {
                return q(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "set", this).call(this, E(t), r);
            }
        }, {
            key: "delete",
            value: function(t) {
                return q(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "delete", this).call(this, E(t));
            }
        }, {
            key: "get",
            value: function(t) {
                return q(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "getAll", this).call(this, E(t)).join(",");
            }
        }, {
            key: "entries",
            value: function() {
                var t = this, r = q(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "entries", this).call(this), n = [];
                return {
                    next: function() {
                        for (;;) {
                            var e = r.next(), o = e.value, i = e.done, a = o && o[0];
                            if (i || n.indexOf(a) < 0) return f(n, a), {
                                value: [ a, t.get(a) ],
                                done: i
                            };
                        }
                    }
                };
            }
        } ]), e;
    }(xt);
    z.Headers || (z.Headers = Et);
    var Lt = window.Uint8Array, St = window.Uint8ClampedArray, Tt = window.Uint16Array, Pt = window.Uint32Array, Bt = window.Int8Array, Ft = window.Int16Array, Rt = window.Int32Array, Ut = window.Float32Array, It = window.Float64Array, Nt = [ Lt, St, Tt, Pt, Bt, Ft, Rt, Ut, It ], Dt = JSON.parse, qt = String.fromCharCode, Gt = 63, Ct = [ Gt, 127, 31, 15, 7, 3, 1 ], Ht = 6, Mt = window.Blob, zt = window.ArrayBuffer, Kt = window.DataView, Xt = window.Promise, Yt = window.FileReader, Jt = window.FormData, Vt = window.decodeURIComponent, Qt = function() {
        function t() {
            o(this, t), this.bodyUsed = !1;
        }
        return C(t, [ {
            key: "initBody",
            value: function(t) {
                if (this.bodyInit = t, t) if (s(t)) this.bodyText = t; else if (L(t, Mt)) this.bodyBlob = t; else if (L(t, Jt)) this.bodyFormData = t; else if (L(t, URLSearchParams)) this.bodyText = t.toString(); else if (L(t, Kt)) this.bodyArrayBuffer = U(t.buffer), 
                // IE 10-11 can't handle a DataView body.
                this.bodyInit = new Mt([ this.bodyArrayBuffer ]); else {
                    if (!L(t, zt) && !S(t)) throw new Error("unsupported BodyInit type");
                    this.bodyArrayBuffer = U(t);
                } else this.bodyText = "";
                this.headers.get("content-type") || (s(t) ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this.bodyBlob && this.bodyBlob.type ? this.headers.set("content-type", this.bodyBlob.type) : t instanceof URLSearchParams && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
            }
        }, {
            key: "arrayBuffer",
            value: function() {
                return this.bodyArrayBuffer ? this.isUsed || Xt.resolve(this.bodyArrayBuffer) : this.blob().then(function(t) {
                    return B(t, "ArrayBuffer");
                });
            }
        }, {
            key: "blob",
            value: function() {
                var t = this.isUsed;
                if (t) return t;
                if (this.bodyBlob) return Xt.resolve(this.bodyBlob);
                if (this.bodyArrayBuffer) return Xt.resolve(new Mt([ this.bodyArrayBuffer ]));
                if (this.bodyFormData) throw new Error("could not read FormData body as blob");
                return Xt.resolve(new Mt([ this.bodyText ]));
            }
        }, {
            key: "text",
            value: function() {
                var t = this.isUsed;
                if (t) return t;
                if (this.bodyBlob) return B(this.bodyBlob, "Text");
                if (this.bodyArrayBuffer) return Xt.resolve(P(this.bodyArrayBuffer));
                if (this.bodyFormData) throw new Error("could not read FormData body as text");
                return Xt.resolve(this.bodyText);
            }
        }, {
            key: "formData",
            value: function() {
                return this.text().then(R);
            }
        }, {
            key: "json",
            value: function() {
                return this.text().then(Dt);
            }
        }, {
            key: "isUsed",
            get: function() {
                if (this.bodyUsed) return Xt.reject(new Y("Already used"));
                this.bodyUsed = !0;
            }
        } ]), t;
    }(), Wt = function(t) {
        function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            o(this, e);
            var i = n.body, a = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
            if (t instanceof e ? i = a.inheritFrom(t, i, n) : a.url = "" + t, a.credentials = n.credentials || a.credentials || "omit", 
            !n.headers && a.headers || (a.headers = new Et(n.headers)), a.method = (n.method || a.method || "GET").toUpperCase(), 
            a.mode = n.mode || a.mode || null, a.referrer = null, ("GET" === a.method || "HEAD" === a.method) && i) throw new TypeError("Body not allowed for GET or HEAD requests");
            return a.initBody(i), a;
        }
        return n(e, t), C(e, [ {
            key: "inheritFrom",
            value: function(t, e, r) {
                var n = r.headers;
                if (t.bodyUsed) throw new TypeError("Already read");
                return this.url = t.url, this.credentials = t.credentials, n || (this.headers = new Et(t.headers)), 
                this.method = t.method, this.mode = t.mode, e || null === t.bodyInit || (e = t.bodyInit, 
                t.bodyUsed = !0), e;
            }
        }, {
            key: "clone",
            value: function() {
                return new e(this, {
                    body: this.bodyInit
                });
            }
        } ]), e;
    }(Qt), Zt = 200, $t = 300, te = [ 301, 302, 303, 307, 308 ], ee = function(t) {
        function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            o(this, e);
            var i = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
            return i.type = "default", i.status = "status" in n ? n.status : Zt, i.ok = i.status >= Zt && i.status < $t, 
            i.statusText = "statusText" in n ? n.statusText : "OK", i.headers = new Et(n.headers), 
            i.url = n.url || "", i.initBody(t), i;
        }
        return n(e, t), C(e, [ {
            key: "clone",
            value: function() {
                return new e(this.bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new Et(this.headers),
                    url: this.url
                });
            }
        }, {
            key: "redirect",
            value: function(t, r) {
                if (te.indexOf(r) < 0) throw new RangeError("Invalid status code");
                return new e(null, {
                    status: r,
                    headers: {
                        location: t
                    }
                });
            }
        } ], [ {
            key: "error",
            value: function() {
                var t = new e(null, {
                    status: 0,
                    statusText: ""
                });
                return t.type = "error", t;
            }
        } ]), e;
    }(Qt), re = window.Headers, ne = window.XMLHttpRequest;
    // if (!window.fetch) {
    // 	window.fetch = j0Fetch;
    // }
    z.fetch = D, z.Body || (z.Body = Qt), z.Response || (z.Response = ee), z.Request || (z.Request = Wt), 
    z.requestAnimationFrame = z.requestAnimationFrame || z.mozRequestAnimationFrame || z.webkitRequestAnimationFrame || z.msRequestAnimationFrame || function(t) {
        return et(function() {
            t(X.now());
        }, 30);
    };
    var oe = window.clearTimeout;
    z.cancelAnimationFrame = z.cancelAnimationFrame || z.mozCancelAnimationFrame || function(t) {
        return oe(t);
    }, z.global = z;
}();