!function() {
    "use strict";
    function t(t) {
        return Array.isArray(t) ? t : Array.from(t);
    }
    function e(t, e) {
        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !e || "object" != typeof e && "function" != typeof e ? t : e;
    }
    function n(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }
    function r(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t, e) {
        return e = {
            exports: {}
        }, t(e, e.exports), e.exports;
    }
    function i(t) {
        return "string" == typeof t;
    }
    function a(t) {
        return "function" == typeof t;
    }
    function u(t, e, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, o = t.length, i = t[M] ? t[M]() : t;
        if (0 <= o) {
            for (var u = r; u < o; u += 1) if (e.call(n, t[u], u, t)) return;
        } else if (a(i.next)) for (var s = 0; s < z; ) {
            var c = i.next(), f = c.value, l = c.done;
            if (l || r <= s && e.call(n, f, s, t)) return;
            s += 1;
        } else {
            var h = r, d = !0, y = !1, v = void 0;
            try {
                for (var p, w = t[Symbol.iterator](); !(d = (p = w.next()).done); d = !0) {
                    var m = p.value;
                    if (e.call(n, m, h, t)) return;
                    h += 1;
                }
            } catch (t) {
                y = !0, v = t;
            } finally {
                try {
                    !d && w.return && w.return();
                } finally {
                    if (y) throw v;
                }
            }
        }
    }
    function s() {
        var t = this, e = this.length, n = 0;
        return {
            next: function() {
                return {
                    value: t[n],
                    done: e <= n++
                };
            }
        };
    }
    function c(t) {
        for (var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
        return Tt.apply(t, n);
    }
    function f(t) {
        return t;
    }
    function l(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f, n = arguments[2], r = [];
        return u(t, function(o, i) {
            c(r, e.call(n, o, i, t));
        }), r;
    }
    function h(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ",";
        return l(t).join(e);
    }
    function d(t) {
        for (var e = Q(t, 10), n = [], r = 0; r < e; r += 1) c(n, this);
        return h(n, "");
    }
    // let firstImmediate = true;
    // let immediateCount = 0;
    // const tasks = {};
    // const suffix = `_setImmediate${window.immediateId}`;
    // function setImmediatePostMessage(fn) {
    // 	if (firstImmediate) {
    // 		firstImmediate = false;
    // 		addEventListner(window, 'message', function ({data}) {
    // 			if (data.split) {
    // 				const [key] = data.split(suffix);
    // 				const task = tasks[key];
    // 				if (task) {
    // 					task();
    // 				}
    // 				delete tasks[key];
    // 			}
    // 		});
    // 	}
    // 	immediateCount += 1;
    // 	postMessage(`${immediateCount}${suffix}`, '*');
    // 	tasks[immediateCount] = fn;
    // 	return immediateCount;
    // }
    function y(t) {
        return nt(t);
    }
    function v(t, e) {
        var n = 1;
        t(function() {
            4 == (n *= 2) && e();
        }), n += 1;
    }
    function p(t) {
        return t && a(t.then) && a(t.catch);
    }
    function w(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f, n = arguments[2], r = void 0;
        return u(t, function(o, i) {
            if (e.call(n, o, i, t)) return r = o, !0;
        }), r;
    }
    function m(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f, n = arguments[2], r = -1;
        return u(t, function(o, i) {
            if (e.call(n, o, i, t)) return r = i, !0;
        }), r;
    }
    function b(t) {
        for (var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
        return t.splice.apply(t, n);
    }
    function g() {
        return this.entries();
    }
    function k() {
        var t = this, e = this.length, n = 0;
        return {
            next: function() {
                return {
                    value: t[n],
                    done: e <= n++
                };
            }
        };
    }
    function x() {
        var t = this, e = this.length, n = 0;
        return {
            next: function() {
                return {
                    value: t[n],
                    done: e <= n++
                };
            }
        };
    }
    function O() {
        var t = this, e = this.length, n = 0;
        return {
            next: function() {
                return {
                    value: t[n],
                    done: e <= n++
                };
            }
        };
    }
    function _(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f, n = arguments[2], r = [];
        return u(t, function(t, o, i) {
            e.call(n, t, o, i) && c(r, t);
        }), r;
    }
    function A(t, e, n) {
        for (var r in t) if (t.hasOwnProperty(r) && e.call(n, t[r], r, t)) return;
    }
    function j(t) {
        return ("" + t).toLowerCase();
    }
    function E(t) {
        return void 0 === t;
    }
    function L(t, e) {
        return t instanceof e;
    }
    function P(t, e) {
        var n = new FileReader(), r = new Promise(function(r, o) {
            switch (n.onload = function() {
                r(n.result);
            }, n.onerror = function() {
                o(n.error);
            }, e) {
              case "ArrayBuffer":
                n.readAsArrayBuffer(t);
                break;

              case "BinaryString":
                n.readAsBinaryString(t);
                break;

              case "DataURL":
                n.readAsDataURL(t);
                break;

              default:
                n.readAsText(t);
            }
        });
        return r.reader = n, r;
    }
    function S(t) {
        return 0 <= m($t, function(e) {
            return L(t, e);
        });
    }
    function T(t) {
        return t.trim();
    }
    function B(e) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new FormData();
        return u(T(e).split("&"), function(e) {
            if (e) {
                var r = e.split("="), o = t(r), i = o[0], a = o.slice(1);
                i = at(i.replace(/\+/g, " ")), a = at(a.join("=").replace(/\+/g, " ")), n.append(i, a);
            }
        }), n;
    }
    /* eslint-disable no-bitwise */
    function F(t, e, n) {
        for (var r = ne[n], o = 0, i = 0; 0 < n--; ) {
            var a = 0 === n ? r : ee, u = re * i++;
            o |= (t[e + n] & a) << u;
        }
        return X.fromCharCode(o);
    }
    /* eslint-enable no-bitwise */
    function R(t) {
        for (var e = new ft(t), n = [], r = 0; r < e.length; r++) {
            var o = e[r], i = void 0;
            i = o < 128 ? 1 : o < 224 ? 2 : o < 240 ? 3 : o < 248 ? 4 : o < 252 ? 5 : 6, c(n, F(e, r, i)), 
            r += i - 1;
        }
        return n.join("");
    }
    function U(t) {
        if (t.slice) return t.slice(0);
        var e = new ft(t.byteLength);
        return e.set(new ft(t)), e.buffer;
    }
    function I(e) {
        var n = new Headers();
        return e.replace(/\r?\n[\t ]+/, " ").split(/\r?\n/).forEach(function(e) {
            var r = e.split(":"), o = t(r), i = o[0], a = o.slice(1);
            i && n.append(T(i), T(a.join(":")));
        }), n;
    }
    function D(t, e) {
        return new Promise(function(n, r) {
            var o = new ie(t, e), i = new Lt();
            i.onload = function() {
                var t = {
                    status: i.status,
                    statusText: i.statusText,
                    headers: I(i.getAllResponseHeaders() || "")
                };
                t.url = "responseURL" in i ? i.responseURL : t.headers.get("X-Request-URL");
                var e = "response" in i ? i.response : i.responseText;
                n(new ce(e, t));
            }, i.onerror = function() {
                r(new TypeError("Network request failed"));
            }, i.ontimeout = function() {
                r(new TypeError("Network request failed"));
            }, i.open(o.method, o.url, !0), "include" === o.credentials && (i.withCredentials = !0), 
            i.responseType = "blob", u(o.headers, function(t) {
                var e = q(t, 2), n = e[0], r = e[1];
                i.setRequestHeader(n, r);
            }), i.send(E(o.bodyInit) ? null : o.bodyInit);
        });
    }
    var N = function t(e, n, r) {
        null === e && (e = Function.prototype);
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (void 0 === o) {
            var i = Object.getPrototypeOf(e);
            return null === i ? void 0 : t(i, n, r);
        }
        if ("value" in o) return o.value;
        var a = o.get;
        if (void 0 !== a) return a.call(r);
    }, q = function() {
        function t(t, e) {
            var n = [], r = !0, o = !1, i = void 0;
            try {
                for (var a, u = t[Symbol.iterator](); !(r = (a = u.next()).done) && (n.push(a.value), 
                !e || n.length !== e); r = !0) ;
            } catch (t) {
                o = !0, i = t;
            } finally {
                try {
                    !r && u.return && u.return();
                } finally {
                    if (o) throw i;
                }
            }
            return n;
        }
        return function(e, n) {
            if (Array.isArray(e)) return e;
            if (Symbol.iterator in Object(e)) return t(e, n);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }(), C = function() {
        function t(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), 
                Object.defineProperty(t, r.key, r);
            }
        }
        return function(e, n, r) {
            return n && t(e.prototype, n), r && t(e, r), e;
        };
    }(), G = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t;
    } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, H = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, M = (o(function(t) {
        /**
  * Copyright (c) 2014, Facebook, Inc.
  * All rights reserved.
  *
  * This source code is licensed under the BSD-style license found in the
  * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
  * additional grant of patent rights can be found in the PATENTS file in
  * the same directory.
  */
        !function(e) {
            function n(t, e, n, r) {
                // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
                var i = e && e.prototype instanceof o ? e : o, a = Object.create(i.prototype), u = new d(r || []);
                // The ._invoke method unifies the implementations of the .next,
                // .throw, and .return methods.
                return a._invoke = c(t, n, u), a;
            }
            // Try/catch helper to minimize deoptimizations. Returns a completion
            // record like context.tryEntries[i].completion. This interface could
            // have been (and was previously) designed to take a closure to be
            // invoked without arguments, but in all the cases we care about we
            // already have an existing method we want to call, so there's no need
            // to create a new function object. We can even get away with assuming
            // the method takes exactly one argument, since that happens to be true
            // in every case, so we don't have to touch the arguments object. The
            // only additional allocation required is the completion record, which
            // has a stable shape and so hopefully should be cheap to allocate.
            function r(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    };
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    };
                }
            }
            // Dummy constructor functions that we use as the .constructor and
            // .constructor.prototype properties for functions that return Generator
            // objects. For full spec compliance, you may wish to configure your
            // minifier not to mangle the names of these two functions.
            function o() {}
            function i() {}
            function a() {}
            // Helper for defining the .next, .throw, and .return methods of the
            // Iterator interface in terms of a single ._invoke method.
            function u(t) {
                [ "next", "throw", "return" ].forEach(function(e) {
                    t[e] = function(t) {
                        return this._invoke(e, t);
                    };
                });
            }
            function s(t) {
                function n(e, o, i, a) {
                    var u = r(t[e], t, o);
                    if ("throw" !== u.type) {
                        var s = u.arg, c = s.value;
                        return c && "object" === (void 0 === c ? "undefined" : G(c)) && m.call(c, "__await") ? Promise.resolve(c.__await).then(function(t) {
                            n("next", t, i, a);
                        }, function(t) {
                            n("throw", t, i, a);
                        }) : Promise.resolve(c).then(function(t) {
                            // When a yielded Promise is resolved, its final value becomes
                            // the .value of the Promise<{value,done}> result for the
                            // current iteration. If the Promise is rejected, however, the
                            // result for this iteration will be rejected with the same
                            // reason. Note that rejections of yielded Promises are not
                            // thrown back into the generator function, as is the case
                            // when an awaited Promise is rejected. This difference in
                            // behavior between yield and await is important, because it
                            // allows the consumer to decide what to do with the yielded
                            // rejection (swallow it and continue, manually .throw it back
                            // into the generator, abandon iteration, whatever). With
                            // await, by contrast, there is no opportunity to examine the
                            // rejection reason outside the generator function, so the
                            // only option is to throw it from the await expression, and
                            // let the generator function handle the exception.
                            s.value = t, i(s);
                        }, a);
                    }
                    a(u.arg);
                }
                function o(t, e) {
                    function r() {
                        return new Promise(function(r, o) {
                            n(t, e, r, o);
                        });
                    }
                    // If enqueue has been called before, then we want to wait until
                    // all previous Promises have been resolved before calling invoke,
                    // so that results are always delivered in the correct order. If
                    // enqueue has not been called before, then it is important to
                    // call invoke immediately, without waiting on a callback to fire,
                    // so that the async generator function has the opportunity to do
                    // any necessary setup in a predictable way. This predictability
                    // is why the Promise constructor synchronously invokes its
                    // executor callback, and why async functions synchronously
                    // execute code before the first await. Since we implement simple
                    // async functions in terms of async generators, it is especially
                    // important to get this right, even though it requires care.
                    // Avoid propagating failures to Promises returned by later
                    // invocations of the iterator.
                    return i = i ? i.then(r, r) : r();
                }
                "object" === G(e.process) && e.process.domain && (n = e.process.domain.bind(n));
                var i;
                // Define the unified helper method that is used to implement .next,
                // .throw, and .return (see defineIteratorMethods).
                this._invoke = o;
            }
            function c(t, e, n) {
                var o = A;
                return function(i, a) {
                    if (o === E) throw new Error("Generator is already running");
                    if (o === L) {
                        if ("throw" === i) throw a;
                        // Be forgiving, per 25.3.3.3.3 of the spec:
                        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                        return v();
                    }
                    for (n.method = i, n.arg = a; ;) {
                        var u = n.delegate;
                        if (u) {
                            var s = f(u, n);
                            if (s) {
                                if (s === P) continue;
                                return s;
                            }
                        }
                        if ("next" === n.method) // Setting context._sent for legacy support of Babel's
                        // function.sent implementation.
                        n.sent = n._sent = n.arg; else if ("throw" === n.method) {
                            if (o === A) throw o = L, n.arg;
                            n.dispatchException(n.arg);
                        } else "return" === n.method && n.abrupt("return", n.arg);
                        o = E;
                        var c = r(t, e, n);
                        if ("normal" === c.type) {
                            if (// If an exception is thrown from innerFn, we leave state ===
                            // GenStateExecuting and loop back for another invocation.
                            o = n.done ? L : j, c.arg === P) continue;
                            return {
                                value: c.arg,
                                done: n.done
                            };
                        }
                        "throw" === c.type && (o = L, // Dispatch the exception by looping back around to the
                        // context.dispatchException(context.arg) call above.
                        n.method = "throw", n.arg = c.arg);
                    }
                };
            }
            // Call delegate.iterator[context.method](context.arg) and handle the
            // result, either by returning a { value, done } result from the
            // delegate iterator, or by modifying context.method and context.arg,
            // setting context.delegate to null, and returning the ContinueSentinel.
            function f(t, e) {
                var n = t.iterator[e.method];
                if (n === p) {
                    if (// A .throw or .return when the delegate iterator has no .throw
                    // method always terminates the yield* loop.
                    e.delegate = null, "throw" === e.method) {
                        if (t.iterator.return && (// If the delegate iterator has a return method, give it a
                        // chance to clean up.
                        e.method = "return", e.arg = p, f(t, e), "throw" === e.method)) // If maybeInvokeDelegate(context) changed context.method from
                        // "return" to "throw", let that override the TypeError below.
                        return P;
                        e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method");
                    }
                    return P;
                }
                var o = r(n, t.iterator, e.arg);
                if ("throw" === o.type) return e.method = "throw", e.arg = o.arg, e.delegate = null, 
                P;
                var i = o.arg;
                // Assign the result of the finished delegate to the temporary
                // variable specified by delegate.resultName (see delegateYield).
                // Resume execution at the desired location (see delegateYield).
                // If context.method was "throw" but the delegate handled the
                // exception, let the outer generator proceed normally. If
                // context.method was "next", forget context.arg since it has been
                // "consumed" by the delegate iterator. If context.method was
                // "return", allow the original .return call to continue in the
                // outer generator.
                // The delegate iterator is finished, so forget it and continue with
                // the outer generator.
                return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", 
                e.arg = p), e.delegate = null, P) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), 
                e.delegate = null, P);
            }
            function l(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), 
                this.tryEntries.push(e);
            }
            function h(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e;
            }
            function d(t) {
                // The root entry object (effectively a try statement without a catch
                // or a finally block) gives us a place to store values thrown from
                // locations where there is no enclosing try statement.
                this.tryEntries = [ {
                    tryLoc: "root"
                } ], t.forEach(l, this), this.reset(!0);
            }
            function y(t) {
                if (t) {
                    var e = t[g];
                    if (e) return e.call(t);
                    if ("function" == typeof t.next) return t;
                    if (!isNaN(t.length)) {
                        var n = -1, r = function e() {
                            for (;++n < t.length; ) if (m.call(t, n)) return e.value = t[n], e.done = !1, e;
                            return e.value = p, e.done = !0, e;
                        };
                        return r.next = r;
                    }
                }
                // Return an iterator with no values.
                return {
                    next: v
                };
            }
            function v() {
                return {
                    value: p,
                    done: !0
                };
            }
            var p, w = Object.prototype, m = w.hasOwnProperty, b = "function" == typeof Symbol ? Symbol : {}, g = b.iterator || "@@iterator", k = b.asyncIterator || "@@asyncIterator", x = b.toStringTag || "@@toStringTag", O = !0, _ = e.regeneratorRuntime;
            if (_) // Don't bother evaluating the rest of this file if the runtime was
            // already defined globally.
            // If regeneratorRuntime is defined globally and we're in a module,
            // make the exports object identical to regeneratorRuntime.
            return void (O && (t.exports = _));
            // Define the runtime globally (as expected by generated code) as either
            // module.exports (if we're in a module) or a new, empty object.
            _ = e.regeneratorRuntime = O ? t.exports : {}, _.wrap = n;
            var A = "suspendedStart", j = "suspendedYield", E = "executing", L = "completed", P = {}, S = {};
            S[g] = function() {
                return this;
            };
            var T = Object.getPrototypeOf, B = T && T(T(y([])));
            B && B !== w && m.call(B, g) && (// This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            S = B);
            var F = a.prototype = o.prototype = Object.create(S);
            i.prototype = F.constructor = a, a.constructor = i, a[x] = i.displayName = "GeneratorFunction", 
            _.isGeneratorFunction = function(t) {
                var e = "function" == typeof t && t.constructor;
                // For the native GeneratorFunction constructor, the best we can
                // do is to check its .name property.
                return !!e && (e === i || "GeneratorFunction" === (e.displayName || e.name));
            }, _.mark = function(t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, a) : (t.__proto__ = a, x in t || (t[x] = "GeneratorFunction")), 
                t.prototype = Object.create(F), t;
            }, // Within the body of any async function, `await x` is transformed to
            // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
            // `hasOwn.call(value, "__await")` to determine if the yielded value is
            // meant to be awaited.
            _.awrap = function(t) {
                return {
                    __await: t
                };
            }, u(s.prototype), s.prototype[k] = function() {
                return this;
            }, _.AsyncIterator = s, // Note that simple async functions are implemented on top of
            // AsyncIterator objects; they just return a Promise for the value of
            // the final result produced by the iterator.
            _.async = function(t, e, r, o) {
                var i = new s(n(t, e, r, o));
                return _.isGeneratorFunction(e) ? i : i.next().then(function(t) {
                    return t.done ? t.value : i.next();
                });
            }, // Define Generator.prototype.{next,throw,return} in terms of the
            // unified ._invoke helper method.
            u(F), F[x] = "Generator", // A Generator should always return itself as the iterator object when the
            // @@iterator function is called on it. Some browsers' implementations of the
            // iterator prototype chain incorrectly implement this, causing the Generator
            // object to not be returned from this call. This ensures that doesn't happen.
            // See https://github.com/facebook/regenerator/issues/274 for more details.
            F[g] = function() {
                return this;
            }, F.toString = function() {
                return "[object Generator]";
            }, _.keys = function(t) {
                var e = [];
                for (var n in t) e.push(n);
                // Rather than returning an object with a next method, we keep
                // things simple and return the next function itself.
                return e.reverse(), function n() {
                    for (;e.length; ) {
                        var r = e.pop();
                        if (r in t) return n.value = r, n.done = !1, n;
                    }
                    // To avoid creating an additional object, we just hang the .value
                    // and .done properties off the next function object itself. This
                    // also ensures that the minifier will not anonymize the function.
                    return n.done = !0, n;
                };
            }, _.values = y, d.prototype = {
                constructor: d,
                reset: function(t) {
                    if (this.prev = 0, this.next = 0, // Resetting context._sent for legacy support of Babel's
                    // function.sent implementation.
                    this.sent = this._sent = p, this.done = !1, this.delegate = null, this.method = "next", 
                    this.arg = p, this.tryEntries.forEach(h), !t) for (var e in this) // Not sure about the optimal order of these conditions:
                    "t" === e.charAt(0) && m.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = p);
                },
                stop: function() {
                    this.done = !0;
                    var t = this.tryEntries[0], e = t.completion;
                    if ("throw" === e.type) throw e.arg;
                    return this.rval;
                },
                dispatchException: function(t) {
                    function e(e, r) {
                        // If the dispatched exception was caught by a catch block,
                        // then let that catch block handle the exception normally.
                        return i.type = "throw", i.arg = t, n.next = e, r && (n.method = "next", n.arg = p), 
                        !!r;
                    }
                    if (this.done) throw t;
                    for (var n = this, r = this.tryEntries.length - 1; r >= 0; --r) {
                        var o = this.tryEntries[r], i = o.completion;
                        if ("root" === o.tryLoc) // Exception thrown outside of any try block that could handle
                        // it, so set the completion value of the entire function to
                        // throw the exception.
                        return e("end");
                        if (o.tryLoc <= this.prev) {
                            var a = m.call(o, "catchLoc"), u = m.call(o, "finallyLoc");
                            if (a && u) {
                                if (this.prev < o.catchLoc) return e(o.catchLoc, !0);
                                if (this.prev < o.finallyLoc) return e(o.finallyLoc);
                            } else if (a) {
                                if (this.prev < o.catchLoc) return e(o.catchLoc, !0);
                            } else {
                                if (!u) throw new Error("try statement without catch or finally");
                                if (this.prev < o.finallyLoc) return e(o.finallyLoc);
                            }
                        }
                    }
                },
                abrupt: function(t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var r = this.tryEntries[n];
                        if (r.tryLoc <= this.prev && m.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                            var o = r;
                            break;
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (// Ignore the finally entry if control is not jumping to a
                    // location outside the try/catch block.
                    o = null);
                    var i = o ? o.completion : {};
                    return i.type = t, i.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, 
                    P) : this.complete(i);
                },
                complete: function(t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, 
                    this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), 
                    P;
                },
                finish: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), h(n), P;
                    }
                },
                catch: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var o = r.arg;
                                h(n);
                            }
                            return o;
                        }
                    }
                    // The context.catch method must only be called with a location
                    // argument that corresponds to a known catch block.
                    throw new Error("illegal catch attempt");
                },
                delegateYield: function(t, e, n) {
                    // Deliberately forget the last sent value so that we don't
                    // accidentally pass it on to the delegate.
                    return this.delegate = {
                        iterator: y(t),
                        resultName: e,
                        nextLoc: n
                    }, "next" === this.method && (this.arg = p), P;
                }
            };
        }(// Among the various tricks for obtaining a reference to the global
        // object, this seems to be the most reliable technique that does not
        // use indirect eval (which violates Content Security Policy).
        "object" === (void 0 === H ? "undefined" : G(H)) ? H : "object" === ("undefined" == typeof window ? "undefined" : G(window)) ? window : "object" === ("undefined" == typeof self ? "undefined" : G(self)) ? self : H);
    }), Symbol.iterator), z = 9007199254740991, K = window, X = K.String, Y = window, J = Y.Object, V = window, Q = V.parseInt, W = window, Z = W.ArrayBuffer, $ = window, tt = $.DataView, et = window, nt = et.setTimeout, rt = window, ot = rt.clearTimeout, it = window, at = it.decodeURIComponent, ut = window, st = ut.TypeError, ct = window, ft = ct.Uint8Array, lt = window, ht = lt.Uint8ClampedArray, dt = window, yt = dt.Uint16Array, vt = window, pt = vt.Uint32Array, wt = window, mt = wt.Int8Array, bt = window, gt = bt.Int16Array, kt = window, xt = kt.Int32Array, Ot = window, _t = Ot.Float32Array, At = window, jt = At.Float64Array, Et = window, Lt = Et.XMLHttpRequest, Pt = 16, St = function() {
        function t() {
            r(this, t), this.seed = Date.now(), this.registry = [];
        }
        return C(t, [ {
            key: "get",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now(), n = "Symbol(" + t + ")" + (this.seed + this.registry.length).toString(Pt);
                return this.registry.push([ n, "" + t + e ]), n;
            }
        }, {
            key: "for",
            value: function(t) {
                if (i(t)) {
                    for (var e = this.registry.length, n = 0; n < e; n += 1) {
                        var r = this.registry[n];
                        if (t === r[1]) return r[0];
                    }
                    return this.get(t, "");
                }
                throw new st("Symbol.for was called with non-string: " + t);
            }
        }, {
            key: "keyFor",
            value: function(t) {
                for (var e = this.registry.length, n = 0; n < e; n += 1) {
                    var r = this.registry[n];
                    if (t === r[0]) return r[1];
                }
            }
        }, {
            key: "Symbol",
            get: function() {
                function t(t, e) {
                    J.defineProperty(n, t, {
                        value: e
                    });
                }
                var e = this, n = function(t) {
                    return e.get(t);
                };
                return u([ "iterator", "match", "replace", "search", "split", "hasInstance", "isConcatSpreadable", "unscopables", "species", "toPrimitive", "toStringTag" ], function(e) {
                    t(e, n(e));
                }), t("for", function(t) {
                    return e.for(t);
                }), t("keyFor", function(t) {
                    return e.keyFor(t);
                }), n;
            }
        } ]), t;
    }();
    window.Symbol || (window.Symbol = new St().Symbol), Array.prototype[M] || (Array.prototype[M] = s);
    var Tt = Array.prototype.push;
    Array.from || (Array.from = l), String.prototype.repeat || (String.prototype.repeat = d), 
    // import postMessage from '../postMessage';
    // import addEventListner from '../dom/addEventListener';
    window.immediateId || (window.immediateId = 0), window.immediateId += 1;
    var Bt = window, Ft = Bt.setImmediate, Rt = void 0;
    Rt = y, nt(function() {
        // if (postMessage) {
        // 	testImmediate(setImmediatePostMessage, function () {
        // 		if (setImmediateAvailable !== setImmediateNative) {
        // 			setImmediateAvailable = setImmediatePostMessage;
        // 		}
        // 	});
        // }
        Ft && v(Ft, function() {
            Rt = Ft;
        });
    });
    var Ut = function(t) {
        return Rt(t);
    }, It = 0, Dt = 1, Nt = 2, qt = 3, Ct = function t() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        r(this, t), /* eslint-disable no-use-before-define */
        this.promise = new Gt(f), /* eslint-enable no-use-before-define */
        this.onResolved = e, this.onRejected = n;
    }, Gt = function() {
        function t(e) {
            r(this, t), this.deferreds = [], this.state = It, this.exec(e);
        }
        return C(t, [ {
            key: "is",
            value: function(t) {
                return this.state === t;
            }
        }, {
            key: "exec",
            value: function(t) {
                var e = this, n = !1, r = function(t) {
                    n || (n = !0, e.resolve(t));
                }, o = function(t) {
                    n || (n = !0, e.reject(t));
                };
                try {
                    t(r, o);
                } catch (t) {
                    o(t);
                }
            }
        }, {
            key: "resolve",
            value: function(t) {
                try {
                    if (t === this) throw new st("A promise cannot be resolved with itself");
                    this.value = t, p(t) ? (this.state = qt, this.exec(function(e, n) {
                        t.then(e, n);
                    })) : this.state = Dt, this.finish();
                } catch (t) {
                    this.reject(t);
                }
            }
        }, {
            key: "reject",
            value: function(t) {
                this.state = Nt, this.value = t, this.finish();
            }
        }, {
            key: "finish",
            value: function() {
                var t = this;
                u(this.deferreds, function(e) {
                    t.handle(e);
                }), this.deferreds = null;
            }
        }, {
            key: "handle",
            value: function(t) {
                /* eslint-enable consistent-this */
                for (/* eslint-disable consistent-this */
                var e = this; e.is(qt); ) e = e.value;
                if (e.is(It)) return void c(e.deferreds, t);
                Ut(function() {
                    var n = t.promise, r = t.onResolved, o = void 0 === r ? null : r, i = t.onRejected, a = void 0 === i ? null : i, u = e.is(Dt), s = u ? o : a;
                    if (null === s) return void (u ? n.resolve(e.value) : n.reject(e.value));
                    var c = void 0;
                    try {
                        c = s(e.value);
                    } catch (t) {
                        return void n.reject(t);
                    }
                    n.resolve(c);
                });
            }
        }, {
            key: "catch",
            value: function(t) {
                return this.then(null, t);
            }
        }, {
            key: "then",
            value: function(t, e) {
                var n = new Ct(t, e);
                return this.handle(n), n.promise;
            }
        } ], [ {
            key: "resolve",
            value: function(e) {
                return p(e) ? e : new t(function(t) {
                    t(e);
                });
            }
        }, {
            key: "reject",
            value: function(e) {
                return new t(function(t, n) {
                    n(e);
                });
            }
        }, {
            key: "race",
            value: function(e) {
                return new t(function(t, n) {
                    u(e, function(e) {
                        e.then(t, n);
                    });
                });
            }
        }, {
            key: "all",
            value: function(e) {
                return new t(function(t, n) {
                    function r(o, a) {
                        if (p(o)) return void o.then(function(t) {
                            r(t, a);
                        }, n);
                        e[a] = o, 0 === (i -= 1) && t(e);
                    }
                    var o = e.length;
                    if (0 === o) return void t([]);
                    var i = o;
                    u(e, function(t, e) {
                        r(t, e);
                    });
                });
            }
        } ]), t;
    }();
    window.Promise = window.Promise || Gt;
    var Ht = function() {
        function t(e) {
            var n = this;
            r(this, t), this.clear(), e && u(e, function(t) {
                var e = q(t, 2), r = e[0], o = e[1];
                n.set(r, o);
            });
        }
        return C(t, [ {
            key: "clear",
            value: function() {
                this.data = [];
            }
        }, {
            key: "indexOfKey",
            value: function(t) {
                return m(this.data, function(e) {
                    return q(e, 1)[0] === t;
                });
            }
        }, {
            key: "has",
            value: function(t) {
                return 0 <= this.indexOfKey(t);
            }
        }, {
            key: "set",
            value: function(t, e) {
                var n = this.indexOfKey(t);
                return 0 <= n ? this.data[n][1] = e : c(this.data, [ t, e ]), this;
            }
        }, {
            key: "get",
            value: function(t) {
                var e = w(this.data, function(e) {
                    return q(e, 1)[0] === t;
                });
                if (e) return e[1];
            }
        }, {
            key: "delete",
            value: function(t) {
                var e = this.indexOfKey(t);
                return 0 <= e && (b(this.data, e, 1), !0);
            }
        }, {
            key: "entries",
            value: function() {
                return this.data[Symbol.iterator]();
            }
        }, {
            key: "forEach",
            value: function(t, e) {
                u(this.data, t, e);
            }
        }, {
            key: "keys",
            value: function() {
                var t = this.entries();
                return {
                    next: function() {
                        var e = t.next(), n = e.value, r = e.done;
                        return {
                            value: n && n[0],
                            done: r
                        };
                    }
                };
            }
        }, {
            key: "values",
            value: function() {
                var t = this.entries();
                return {
                    next: function() {
                        var e = t.next(), n = e.value, r = e.done;
                        return {
                            value: n && n[1],
                            done: r
                        };
                    }
                };
            }
        }, {
            key: "size",
            get: function() {
                return this.data.length;
            }
        } ]), t;
    }(), Mt = window.Map;
    Mt && 1 === new Mt([ [ 0, 0 ] ]).size && Mt.prototype.forEach || (Mt = Ht), window.Map = Mt, 
    Map.prototype[M] || (Map.prototype[M] = g);
    var zt = function() {
        function t(e) {
            var n = this;
            r(this, t), this.clear(), e && u(e, function(t) {
                n.add(t);
            });
        }
        return C(t, [ {
            key: "clear",
            value: function() {
                this.data = [];
            }
        }, {
            key: "indexOf",
            value: function(t) {
                return this.data.indexOf(t);
            }
        }, {
            key: "has",
            value: function(t) {
                return 0 <= this.indexOf(t);
            }
        }, {
            key: "add",
            value: function(t) {
                return this.has(t) || c(this.data, t), this;
            }
        }, {
            key: "delete",
            value: function(t) {
                var e = this.indexOf(t);
                return 0 <= e && b(this.data, e, 1), 0 <= e;
            }
        }, {
            key: "forEach",
            value: function(t, e) {
                var n = this;
                u(this.data, function(r) {
                    t.call(e, r, r, n);
                });
            }
        }, {
            key: "values",
            value: function() {
                return this.data[M]();
            }
        }, {
            key: M,
            value: function() {
                return this.values();
            }
        }, {
            key: "entries",
            value: function() {
                var t = this.values();
                return {
                    next: function() {
                        var e = t.next(), n = e.value, r = e.done;
                        return {
                            value: !r && [ n, n ],
                            done: r
                        };
                    }
                };
            }
        }, {
            key: "size",
            get: function() {
                return this.data.length;
            }
        } ]), t;
    }(), Kt = window.Set;
    Kt && 1 === new Kt([ 0 ]).size && Kt.prototype.forEach || (Kt = zt), window.Set = Kt, 
    NodeList.prototype[M] || (NodeList.prototype[M] = k), HTMLCollection.prototype[M] || (HTMLCollection.prototype[M] = x), 
    NamedNodeMap.prototype[M] || (NamedNodeMap.prototype[M] = O);
    var Xt = function() {
        function t(e) {
            var n = this;
            r(this, t), this.clear(), e && l(e, function(t) {
                var e = q(t, 2), r = e[0], o = e[1];
                n.append(r, o);
            });
        }
        return C(t, [ {
            key: "clear",
            value: function() {
                this.data = [];
            }
        }, {
            key: "indexOf",
            value: function(t) {
                return m(this.data, function(e) {
                    return q(e, 1)[0] === t;
                });
            }
        }, {
            key: "has",
            value: function(t) {
                return 0 <= this.indexOf(t);
            }
        }, {
            key: "append",
            value: function(t, e) {
                c(this.data, [ t, e ]);
            }
        }, {
            key: "set",
            value: function(t, e) {
                var n = this.indexOf(t);
                n < 0 ? this.append(t, e) : this.data[n][1] = e;
            }
        }, {
            key: "delete",
            value: function(t) {
                this.data = _(this.data, function(e) {
                    return q(e, 1)[0] !== t;
                });
            }
        }, {
            key: "get",
            value: function(t) {
                var e = w(this.data, function(e) {
                    return q(e, 1)[0] === t;
                });
                return e ? e[1] : null;
            }
        }, {
            key: "getAll",
            value: function(t) {
                var e = [];
                return u(this.data, function(n) {
                    var r = q(n, 2), o = r[0], i = r[1];
                    o === t && c(e, i);
                }), e;
            }
        }, {
            key: "toString",
            value: function() {
                return l(this.data, function(t) {
                    var e = q(t, 2), n = e[0], r = e[1];
                    return n + ":" + (void 0 === r ? "" : r);
                }).join(",");
            }
        }, {
            key: "entries",
            value: function() {
                return this.data[M]();
            }
        }, {
            key: "values",
            value: function() {
                var t = this.entries();
                return {
                    next: function() {
                        var e = t.next(), n = e.value, r = e.done;
                        return {
                            value: n && n[1],
                            done: r
                        };
                    }
                };
            }
        }, {
            key: M,
            value: function() {
                return this.entries();
            }
        } ]), t;
    }(), Yt = "&", Jt = "=", Vt = function(t) {
        function o(t) {
            return r(this, o), e(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, t ? l(t.replace(/^\?/, "").split(Yt), function(t) {
                return t.split(Jt);
            }) : null));
        }
        return n(o, t), C(o, [ {
            key: "toString",
            value: function() {
                return l(this.data, function(t) {
                    var e = q(t, 2), n = e[0], r = e[1];
                    return n + "=" + (void 0 === r ? "" : r);
                }).join("&");
            }
        } ]), o;
    }(Xt), Qt = window, Wt = Qt.URLSearchParams;
    Wt && new Wt("?a=b").has("a") || (window.URLSearchParams = Vt);
    var Zt = function(t) {
        function o(t) {
            r(this, o);
            var n = [];
            return t && A(t, function(t, e) {
                c(n, [ e, t ]);
            }), e(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, n));
        }
        return n(o, t), C(o, [ {
            key: "indexOf",
            value: function(t) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "indexOf", this).call(this, j(t));
            }
        }, {
            key: "has",
            value: function(t) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "has", this).call(this, j(t));
            }
        }, {
            key: "append",
            value: function(t, e) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "append", this).call(this, j(t), e);
            }
        }, {
            key: "set",
            value: function(t, e) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "set", this).call(this, j(t), e);
            }
        }, {
            key: "delete",
            value: function(t) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "delete", this).call(this, j(t));
            }
        }, {
            key: "get",
            value: function(t) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "getAll", this).call(this, j(t)).join(",");
            }
        }, {
            key: "entries",
            value: function() {
                var t = this, e = N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "entries", this).call(this), n = [];
                return {
                    next: function() {
                        for (;;) {
                            var r = e.next(), o = r.value, i = r.done, a = o && o[0];
                            if (i || n.indexOf(a) < 0) return c(n, a), {
                                value: [ a, t.get(a) ],
                                done: i
                            };
                        }
                    }
                };
            }
        } ]), o;
    }(Xt);
    window.Headers || (window.Headers = Zt);
    var $t = [ ft, ht, yt, pt, mt, gt, xt, _t, jt ], te = JSON.parse, ee = 63, ne = [ ee, 127, 31, 15, 7, 3, 1 ], re = 6, oe = function() {
        function t() {
            r(this, t), this.bodyUsed = !1;
        }
        return C(t, [ {
            key: "initBody",
            value: function(t) {
                if (this.bodyInit = t, t) if (i(t)) this.bodyText = t; else if (L(t, Blob)) this.bodyBlob = t; else if (L(t, FormData)) this.bodyFormData = t; else if (L(t, URLSearchParams)) this.bodyText = t.toString(); else if (L(t, tt)) this.bodyArrayBuffer = U(t.buffer), 
                // IE 10-11 can't handle a DataView body.
                this.bodyInit = new Blob([ this.bodyArrayBuffer ]); else {
                    if (!L(t, Z) && !S(t)) throw new Error("unsupported BodyInit type");
                    this.bodyArrayBuffer = U(t);
                } else this.bodyText = "";
                this.headers.get("content-type") || (i(t) ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this.bodyBlob && this.bodyBlob.type ? this.headers.set("content-type", this.bodyBlob.type) : t instanceof URLSearchParams && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
            }
        }, {
            key: "arrayBuffer",
            value: function() {
                return this.bodyArrayBuffer ? this.isUsed || Promise.resolve(this.bodyArrayBuffer) : this.blob().then(function(t) {
                    return P(t, "ArrayBuffer");
                });
            }
        }, {
            key: "blob",
            value: function() {
                var t = this.isUsed;
                if (t) return t;
                if (this.bodyBlob) return Promise.resolve(this.bodyBlob);
                if (this.bodyArrayBuffer) return Promise.resolve(new Blob([ this.bodyArrayBuffer ]));
                if (this.bodyFormData) throw new Error("could not read FormData body as blob");
                return Promise.resolve(new Blob([ this.bodyText ]));
            }
        }, {
            key: "text",
            value: function() {
                var t = this.isUsed;
                if (t) return t;
                if (this.bodyBlob) return P(this.bodyBlob, "Text");
                if (this.bodyArrayBuffer) return Promise.resolve(R(this.bodyArrayBuffer));
                if (this.bodyFormData) throw new Error("could not read FormData body as text");
                return Promise.resolve(this.bodyText);
            }
        }, {
            key: "formData",
            value: function() {
                return this.text().then(B);
            }
        }, {
            key: "json",
            value: function() {
                return this.text().then(te);
            }
        }, {
            key: "isUsed",
            get: function() {
                if (this.bodyUsed) return Promise.reject(new st("Already used"));
                this.bodyUsed = !0;
            }
        } ]), t;
    }(), ie = function(t) {
        function o(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            r(this, o);
            var i = n.body, a = e(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this));
            if (t instanceof o ? i = a.inheritFrom(t, i, n) : a.url = "" + t, a.credentials = n.credentials || a.credentials || "omit", 
            !n.headers && a.headers || (a.headers = new Zt(n.headers)), a.method = (n.method || a.method || "GET").toUpperCase(), 
            a.mode = n.mode || a.mode || null, a.referrer = null, ("GET" === a.method || "HEAD" === a.method) && i) throw new TypeError("Body not allowed for GET or HEAD requests");
            return a.initBody(i), a;
        }
        return n(o, t), C(o, [ {
            key: "inheritFrom",
            value: function(t, e, n) {
                var r = n.headers;
                if (t.bodyUsed) throw new TypeError("Already read");
                return this.url = t.url, this.credentials = t.credentials, r || (this.headers = new Zt(t.headers)), 
                this.method = t.method, this.mode = t.mode, e || null === t.bodyInit || (e = t.bodyInit, 
                t.bodyUsed = !0), e;
            }
        }, {
            key: "clone",
            value: function() {
                return new o(this, {
                    body: this.bodyInit
                });
            }
        } ]), o;
    }(oe), ae = 200, ue = 300, se = [ 301, 302, 303, 307, 308 ], ce = function(t) {
        function o(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            r(this, o);
            var i = e(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this));
            return i.type = "default", i.status = "status" in n ? n.status : ae, i.ok = i.status >= ae && i.status < ue, 
            i.statusText = "statusText" in n ? n.statusText : "OK", i.headers = new Zt(n.headers), 
            i.url = n.url || "", i.initBody(t), i;
        }
        return n(o, t), C(o, [ {
            key: "clone",
            value: function() {
                return new o(this.bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new Zt(this.headers),
                    url: this.url
                });
            }
        }, {
            key: "redirect",
            value: function(t, e) {
                if (se.indexOf(e) < 0) throw new RangeError("Invalid status code");
                return new o(null, {
                    status: e,
                    headers: {
                        location: t
                    }
                });
            }
        } ], [ {
            key: "error",
            value: function() {
                var t = new o(null, {
                    status: 0,
                    statusText: ""
                });
                return t.type = "error", t;
            }
        } ]), o;
    }(oe);
    // if (!window.fetch) {
    // 	window.fetch = j0Fetch;
    // }
    window.fetch = D, window.Body || (window.Body = oe), window.Response || (window.Response = ce), 
    window.Request || (window.Request = ie), window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
        return nt(function() {
            t(Date.now());
        }, 30);
    }, window.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || function(t) {
        return ot(t);
    }, window.global = window;
}();