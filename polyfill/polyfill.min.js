!function() {
    "use strict";
    function t(t) {
        return Array.isArray(t) ? t : Array.from(t);
    }
    function e(t, e) {
        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !e || "object" != typeof e && "function" != typeof e ? t : e;
    }
    function r(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }
    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t, e) {
        return e = {
            exports: {}
        }, t(e, e.exports), e.exports;
    }
    function i(t) {
        return "string" == typeof t;
    }
    function a() {
        var t = this, e = this.length, r = 0;
        return {
            next: function() {
                return {
                    value: t[r],
                    done: e <= r++
                };
            }
        };
    }
    function u(t) {
        return "function" == typeof t;
    }
    function s(t, e, r) {
        var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, o = t.length, i = t[K] ? t[K]() : t;
        if (0 <= o) {
            for (var a = n; a < o; a += 1) if (e.call(r, t[a], a, t)) return;
        } else if (u(i.next)) for (var s = 0; s < X; ) {
            var c = i.next(), f = c.value, l = c.done;
            if (l || n <= s && e.call(r, f, s, t)) return;
            s += 1;
        } else {
            var h = n, d = !0, y = !1, v = void 0;
            try {
                for (var p, w = t[Symbol.iterator](); !(d = (p = w.next()).done); d = !0) {
                    var m = p.value;
                    if (e.call(r, m, h, t)) return;
                    h += 1;
                }
            } catch (t) {
                y = !0, v = t;
            } finally {
                try {
                    !d && w.return && w.return();
                } finally {
                    if (y) throw v;
                }
            }
        }
    }
    function c(t) {
        for (var e, r = arguments.length, n = Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) n[o - 1] = arguments[o];
        return (e = Array.prototype.push).call.apply(e, [ t ].concat(n));
    }
    function f(t) {
        return t;
    }
    function l(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f, r = arguments[2], n = [];
        return s(t, function(o, i) {
            c(n, e.call(r, o, i, t));
        }), n;
    }
    function h(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ",";
        return l(t).join(e);
    }
    function d(t) {
        for (var e = parseInt(t, 10), r = [], n = 0; n < e; n += 1) c(r, this);
        return h(r, "");
    }
    // let firstImmediate = true;
    // let immediateCount = 0;
    // const tasks = {};
    // const suffix = `_setImmediate${window.immediateId}`;
    // function setImmediatePostMessage(fn) {
    // 	if (firstImmediate) {
    // 		firstImmediate = false;
    // 		addEventListner(window, 'message', function ({data}) {
    // 			if (data.split) {
    // 				const [key] = data.split(suffix);
    // 				const task = tasks[key];
    // 				if (task) {
    // 					task();
    // 				}
    // 				delete tasks[key];
    // 			}
    // 		});
    // 	}
    // 	immediateCount += 1;
    // 	postMessage(`${immediateCount}${suffix}`, '*');
    // 	tasks[immediateCount] = fn;
    // 	return immediateCount;
    // }
    function y(t) {
        return setTimeout(t);
    }
    function v(t, e) {
        var r = 1;
        t(function() {
            4 == (r *= 2) && e();
        }), r += 1;
    }
    function p(t) {
        return t && u(t.then) && u(t.catch);
    }
    function w(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f, r = arguments[2], n = void 0;
        return s(t, function(o, i) {
            if (e.call(r, o, i, t)) return n = o, !0;
        }), n;
    }
    function m(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f, r = arguments[2], n = -1;
        return s(t, function(o, i) {
            if (e.call(r, o, i, t)) return n = i, !0;
        }), n;
    }
    function b(t) {
        for (var e = arguments.length, r = Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) r[n - 1] = arguments[n];
        return t.splice.apply(t, r);
    }
    function g() {
        return this.entries();
    }
    function k() {
        var t = this, e = this.length, r = 0;
        return {
            next: function() {
                return {
                    value: t[r],
                    done: e <= r++
                };
            }
        };
    }
    function x() {
        var t = this, e = this.length, r = 0;
        return {
            next: function() {
                return {
                    value: t[r],
                    done: e <= r++
                };
            }
        };
    }
    function O() {
        var t = this, e = this.length, r = 0;
        return {
            next: function() {
                return {
                    value: t[r],
                    done: e <= r++
                };
            }
        };
    }
    function _(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f, r = arguments[2], n = [];
        return s(t, function(t, o, i) {
            e.call(r, t, o, i) && c(n, t);
        }), n;
    }
    function A(t, e, r) {
        for (var n in t) if (t.hasOwnProperty(n) && e.call(r, t[n], n, t)) return;
    }
    function j(t) {
        return ("" + t).toLowerCase();
    }
    function E(t) {
        return void 0 === t;
    }
    function L(t, e) {
        return t instanceof e;
    }
    function T(t, e) {
        var r = new FileReader(), n = new Promise(function(n, o) {
            switch (r.onload = function() {
                n(r.result);
            }, r.onerror = function() {
                o(r.error);
            }, e) {
              case "ArrayBuffer":
                r.readAsArrayBuffer(t);
                break;

              case "BinaryString":
                r.readAsBinaryString(t);
                break;

              case "DataURL":
                r.readAsDataURL(t);
                break;

              default:
                r.readAsText(t);
            }
        });
        return n.reader = r, n;
    }
    function P(t) {
        return 0 <= m(yt, function(e) {
            return L(t, e);
        });
    }
    /* eslint-disable no-bitwise */
    function S(t, e, r) {
        for (var n = vt[r], o = 0, i = 0; 0 < r--; ) {
            var a = 0 === r ? n : wt, u = pt * i++;
            o |= (t[e + r] & a) << u;
        }
        return String.fromCharCode(o);
    }
    /* eslint-enable no-bitwise */
    function B(t) {
        for (var e = new Uint8Array(t), r = [], n = 0; n < e.length; n++) {
            var o = e[n], i = void 0;
            i = o < 128 ? 1 : o < 224 ? 2 : o < 240 ? 3 : o < 248 ? 4 : o < 252 ? 5 : 6, c(r, S(e, n, i)), 
            n += i - 1;
        }
        return r.join("");
    }
    function F(t) {
        return t.trim();
    }
    function R(e) {
        var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new FormData();
        return s(F(e).split("&"), function(e) {
            if (e) {
                var n = e.split("="), o = t(n), i = o[0], a = o.slice(1);
                i = decodeURIComponent(i.replace(/\+/g, " ")), a = decodeURIComponent(a.join("=").replace(/\+/g, " ")), 
                r.append(i, a);
            }
        }), r;
    }
    function U(t) {
        if (t.slice) return t.slice(0);
        var e = new Uint8Array(t.byteLength);
        return e.set(new Uint8Array(t)), e.buffer;
    }
    function I(e) {
        var r = new Headers();
        return e.replace(/\r?\n[\t ]+/, " ").split(/\r?\n/).forEach(function(e) {
            var n = e.split(":"), o = t(n), i = o[0], a = o.slice(1);
            i && r.append(F(i), F(a.join(":")));
        }), r;
    }
    function D(t, e) {
        return new Promise(function(r, n) {
            var o = new gt(t, e), i = new XMLHttpRequest();
            i.onload = function() {
                var t = {
                    status: i.status,
                    statusText: i.statusText,
                    headers: I(i.getAllResponseHeaders() || "")
                };
                t.url = "responseURL" in i ? i.responseURL : t.headers.get("X-Request-URL");
                var e = "response" in i ? i.response : i.responseText;
                r(new _t(e, t));
            }, i.onerror = function() {
                n(new TypeError("Network request failed"));
            }, i.ontimeout = function() {
                n(new TypeError("Network request failed"));
            }, i.open(o.method, o.url, !0), "include" === o.credentials && (i.withCredentials = !0), 
            i.responseType = "blob", s(o.headers, function(t) {
                var e = q(t, 2), r = e[0], n = e[1];
                i.setRequestHeader(r, n);
            }), i.send(E(o.bodyInit) ? null : o.bodyInit);
        });
    }
    var N = function t(e, r, n) {
        null === e && (e = Function.prototype);
        var o = Object.getOwnPropertyDescriptor(e, r);
        if (void 0 === o) {
            var i = Object.getPrototypeOf(e);
            return null === i ? void 0 : t(i, r, n);
        }
        if ("value" in o) return o.value;
        var a = o.get;
        if (void 0 !== a) return a.call(n);
    }, q = function() {
        function t(t, e) {
            var r = [], n = !0, o = !1, i = void 0;
            try {
                for (var a, u = t[Symbol.iterator](); !(n = (a = u.next()).done) && (r.push(a.value), 
                !e || r.length !== e); n = !0) ;
            } catch (t) {
                o = !0, i = t;
            } finally {
                try {
                    !n && u.return && u.return();
                } finally {
                    if (o) throw i;
                }
            }
            return r;
        }
        return function(e, r) {
            if (Array.isArray(e)) return e;
            if (Symbol.iterator in Object(e)) return t(e, r);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }(), C = function() {
        function t(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, n.key, n);
            }
        }
        return function(e, r, n) {
            return r && t(e.prototype, r), n && t(e, n), e;
        };
    }(), G = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t;
    } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, H = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, M = (o(function(t) {
        /**
  * Copyright (c) 2014, Facebook, Inc.
  * All rights reserved.
  *
  * This source code is licensed under the BSD-style license found in the
  * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
  * additional grant of patent rights can be found in the PATENTS file in
  * the same directory.
  */
        !function(e) {
            function r(t, e, r, n) {
                // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
                var i = e && e.prototype instanceof o ? e : o, a = Object.create(i.prototype), u = new d(n || []);
                // The ._invoke method unifies the implementations of the .next,
                // .throw, and .return methods.
                return a._invoke = c(t, r, u), a;
            }
            // Try/catch helper to minimize deoptimizations. Returns a completion
            // record like context.tryEntries[i].completion. This interface could
            // have been (and was previously) designed to take a closure to be
            // invoked without arguments, but in all the cases we care about we
            // already have an existing method we want to call, so there's no need
            // to create a new function object. We can even get away with assuming
            // the method takes exactly one argument, since that happens to be true
            // in every case, so we don't have to touch the arguments object. The
            // only additional allocation required is the completion record, which
            // has a stable shape and so hopefully should be cheap to allocate.
            function n(t, e, r) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, r)
                    };
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    };
                }
            }
            // Dummy constructor functions that we use as the .constructor and
            // .constructor.prototype properties for functions that return Generator
            // objects. For full spec compliance, you may wish to configure your
            // minifier not to mangle the names of these two functions.
            function o() {}
            function i() {}
            function a() {}
            // Helper for defining the .next, .throw, and .return methods of the
            // Iterator interface in terms of a single ._invoke method.
            function u(t) {
                [ "next", "throw", "return" ].forEach(function(e) {
                    t[e] = function(t) {
                        return this._invoke(e, t);
                    };
                });
            }
            function s(t) {
                function e(r, o, i, a) {
                    var u = n(t[r], t, o);
                    if ("throw" !== u.type) {
                        var s = u.arg, c = s.value;
                        return c && "object" === (void 0 === c ? "undefined" : G(c)) && m.call(c, "__await") ? Promise.resolve(c.__await).then(function(t) {
                            e("next", t, i, a);
                        }, function(t) {
                            e("throw", t, i, a);
                        }) : Promise.resolve(c).then(function(t) {
                            // When a yielded Promise is resolved, its final value becomes
                            // the .value of the Promise<{value,done}> result for the
                            // current iteration. If the Promise is rejected, however, the
                            // result for this iteration will be rejected with the same
                            // reason. Note that rejections of yielded Promises are not
                            // thrown back into the generator function, as is the case
                            // when an awaited Promise is rejected. This difference in
                            // behavior between yield and await is important, because it
                            // allows the consumer to decide what to do with the yielded
                            // rejection (swallow it and continue, manually .throw it back
                            // into the generator, abandon iteration, whatever). With
                            // await, by contrast, there is no opportunity to examine the
                            // rejection reason outside the generator function, so the
                            // only option is to throw it from the await expression, and
                            // let the generator function handle the exception.
                            s.value = t, i(s);
                        }, a);
                    }
                    a(u.arg);
                }
                function r(t, r) {
                    function n() {
                        return new Promise(function(n, o) {
                            e(t, r, n, o);
                        });
                    }
                    // If enqueue has been called before, then we want to wait until
                    // all previous Promises have been resolved before calling invoke,
                    // so that results are always delivered in the correct order. If
                    // enqueue has not been called before, then it is important to
                    // call invoke immediately, without waiting on a callback to fire,
                    // so that the async generator function has the opportunity to do
                    // any necessary setup in a predictable way. This predictability
                    // is why the Promise constructor synchronously invokes its
                    // executor callback, and why async functions synchronously
                    // execute code before the first await. Since we implement simple
                    // async functions in terms of async generators, it is especially
                    // important to get this right, even though it requires care.
                    // Avoid propagating failures to Promises returned by later
                    // invocations of the iterator.
                    return o = o ? o.then(n, n) : n();
                }
                "object" === ("undefined" == typeof process ? "undefined" : G(process)) && process.domain && (e = process.domain.bind(e));
                var o;
                // Define the unified helper method that is used to implement .next,
                // .throw, and .return (see defineIteratorMethods).
                this._invoke = r;
            }
            function c(t, e, r) {
                var o = _;
                return function(i, a) {
                    if (o === j) throw new Error("Generator is already running");
                    if (o === E) {
                        if ("throw" === i) throw a;
                        // Be forgiving, per 25.3.3.3.3 of the spec:
                        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                        return v();
                    }
                    for (r.method = i, r.arg = a; ;) {
                        var u = r.delegate;
                        if (u) {
                            var s = f(u, r);
                            if (s) {
                                if (s === L) continue;
                                return s;
                            }
                        }
                        if ("next" === r.method) // Setting context._sent for legacy support of Babel's
                        // function.sent implementation.
                        r.sent = r._sent = r.arg; else if ("throw" === r.method) {
                            if (o === _) throw o = E, r.arg;
                            r.dispatchException(r.arg);
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        o = j;
                        var c = n(t, e, r);
                        if ("normal" === c.type) {
                            if (// If an exception is thrown from innerFn, we leave state ===
                            // GenStateExecuting and loop back for another invocation.
                            o = r.done ? E : A, c.arg === L) continue;
                            return {
                                value: c.arg,
                                done: r.done
                            };
                        }
                        "throw" === c.type && (o = E, // Dispatch the exception by looping back around to the
                        // context.dispatchException(context.arg) call above.
                        r.method = "throw", r.arg = c.arg);
                    }
                };
            }
            // Call delegate.iterator[context.method](context.arg) and handle the
            // result, either by returning a { value, done } result from the
            // delegate iterator, or by modifying context.method and context.arg,
            // setting context.delegate to null, and returning the ContinueSentinel.
            function f(t, e) {
                var r = t.iterator[e.method];
                if (r === p) {
                    if (// A .throw or .return when the delegate iterator has no .throw
                    // method always terminates the yield* loop.
                    e.delegate = null, "throw" === e.method) {
                        if (t.iterator.return && (// If the delegate iterator has a return method, give it a
                        // chance to clean up.
                        e.method = "return", e.arg = p, f(t, e), "throw" === e.method)) // If maybeInvokeDelegate(context) changed context.method from
                        // "return" to "throw", let that override the TypeError below.
                        return L;
                        e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method");
                    }
                    return L;
                }
                var o = n(r, t.iterator, e.arg);
                if ("throw" === o.type) return e.method = "throw", e.arg = o.arg, e.delegate = null, 
                L;
                var i = o.arg;
                // Assign the result of the finished delegate to the temporary
                // variable specified by delegate.resultName (see delegateYield).
                // Resume execution at the desired location (see delegateYield).
                // If context.method was "throw" but the delegate handled the
                // exception, let the outer generator proceed normally. If
                // context.method was "next", forget context.arg since it has been
                // "consumed" by the delegate iterator. If context.method was
                // "return", allow the original .return call to continue in the
                // outer generator.
                // The delegate iterator is finished, so forget it and continue with
                // the outer generator.
                return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", 
                e.arg = p), e.delegate = null, L) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), 
                e.delegate = null, L);
            }
            function l(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), 
                this.tryEntries.push(e);
            }
            function h(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e;
            }
            function d(t) {
                // The root entry object (effectively a try statement without a catch
                // or a finally block) gives us a place to store values thrown from
                // locations where there is no enclosing try statement.
                this.tryEntries = [ {
                    tryLoc: "root"
                } ], t.forEach(l, this), this.reset(!0);
            }
            function y(t) {
                if (t) {
                    var e = t[g];
                    if (e) return e.call(t);
                    if ("function" == typeof t.next) return t;
                    if (!isNaN(t.length)) {
                        var r = -1, n = function e() {
                            for (;++r < t.length; ) if (m.call(t, r)) return e.value = t[r], e.done = !1, e;
                            return e.value = p, e.done = !0, e;
                        };
                        return n.next = n;
                    }
                }
                // Return an iterator with no values.
                return {
                    next: v
                };
            }
            function v() {
                return {
                    value: p,
                    done: !0
                };
            }
            var p, w = Object.prototype, m = w.hasOwnProperty, b = "function" == typeof Symbol ? Symbol : {}, g = b.iterator || "@@iterator", k = b.toStringTag || "@@toStringTag", x = !0, O = e.regeneratorRuntime;
            if (O) // Don't bother evaluating the rest of this file if the runtime was
            // already defined globally.
            // If regeneratorRuntime is defined globally and we're in a module,
            // make the exports object identical to regeneratorRuntime.
            return void (x && (t.exports = O));
            // Define the runtime globally (as expected by generated code) as either
            // module.exports (if we're in a module) or a new, empty object.
            O = e.regeneratorRuntime = x ? t.exports : {}, O.wrap = r;
            var _ = "suspendedStart", A = "suspendedYield", j = "executing", E = "completed", L = {}, T = {};
            T[g] = function() {
                return this;
            };
            var P = Object.getPrototypeOf, S = P && P(P(y([])));
            S && S !== w && m.call(S, g) && (// This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            T = S);
            var B = a.prototype = o.prototype = Object.create(T);
            i.prototype = B.constructor = a, a.constructor = i, a[k] = i.displayName = "GeneratorFunction", 
            O.isGeneratorFunction = function(t) {
                var e = "function" == typeof t && t.constructor;
                // For the native GeneratorFunction constructor, the best we can
                // do is to check its .name property.
                return !!e && (e === i || "GeneratorFunction" === (e.displayName || e.name));
            }, O.mark = function(t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, a) : (t.__proto__ = a, k in t || (t[k] = "GeneratorFunction")), 
                t.prototype = Object.create(B), t;
            }, // Within the body of any async function, `await x` is transformed to
            // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
            // `hasOwn.call(value, "__await")` to determine if the yielded value is
            // meant to be awaited.
            O.awrap = function(t) {
                return {
                    __await: t
                };
            }, u(s.prototype), O.AsyncIterator = s, // Note that simple async functions are implemented on top of
            // AsyncIterator objects; they just return a Promise for the value of
            // the final result produced by the iterator.
            O.async = function(t, e, n, o) {
                var i = new s(r(t, e, n, o));
                return O.isGeneratorFunction(e) ? i : i.next().then(function(t) {
                    return t.done ? t.value : i.next();
                });
            }, // Define Generator.prototype.{next,throw,return} in terms of the
            // unified ._invoke helper method.
            u(B), B[k] = "Generator", B.toString = function() {
                return "[object Generator]";
            }, O.keys = function(t) {
                var e = [];
                for (var r in t) e.push(r);
                // Rather than returning an object with a next method, we keep
                // things simple and return the next function itself.
                return e.reverse(), function r() {
                    for (;e.length; ) {
                        var n = e.pop();
                        if (n in t) return r.value = n, r.done = !1, r;
                    }
                    // To avoid creating an additional object, we just hang the .value
                    // and .done properties off the next function object itself. This
                    // also ensures that the minifier will not anonymize the function.
                    return r.done = !0, r;
                };
            }, O.values = y, d.prototype = {
                constructor: d,
                reset: function(t) {
                    if (this.prev = 0, this.next = 0, // Resetting context._sent for legacy support of Babel's
                    // function.sent implementation.
                    this.sent = this._sent = p, this.done = !1, this.delegate = null, this.method = "next", 
                    this.arg = p, this.tryEntries.forEach(h), !t) for (var e in this) // Not sure about the optimal order of these conditions:
                    "t" === e.charAt(0) && m.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = p);
                },
                stop: function() {
                    this.done = !0;
                    var t = this.tryEntries[0], e = t.completion;
                    if ("throw" === e.type) throw e.arg;
                    return this.rval;
                },
                dispatchException: function(t) {
                    function e(e, n) {
                        // If the dispatched exception was caught by a catch block,
                        // then let that catch block handle the exception normally.
                        return i.type = "throw", i.arg = t, r.next = e, n && (r.method = "next", r.arg = p), 
                        !!n;
                    }
                    if (this.done) throw t;
                    for (var r = this, n = this.tryEntries.length - 1; n >= 0; --n) {
                        var o = this.tryEntries[n], i = o.completion;
                        if ("root" === o.tryLoc) // Exception thrown outside of any try block that could handle
                        // it, so set the completion value of the entire function to
                        // throw the exception.
                        return e("end");
                        if (o.tryLoc <= this.prev) {
                            var a = m.call(o, "catchLoc"), u = m.call(o, "finallyLoc");
                            if (a && u) {
                                if (this.prev < o.catchLoc) return e(o.catchLoc, !0);
                                if (this.prev < o.finallyLoc) return e(o.finallyLoc);
                            } else if (a) {
                                if (this.prev < o.catchLoc) return e(o.catchLoc, !0);
                            } else {
                                if (!u) throw new Error("try statement without catch or finally");
                                if (this.prev < o.finallyLoc) return e(o.finallyLoc);
                            }
                        }
                    }
                },
                abrupt: function(t, e) {
                    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                        var n = this.tryEntries[r];
                        if (n.tryLoc <= this.prev && m.call(n, "finallyLoc") && this.prev < n.finallyLoc) {
                            var o = n;
                            break;
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (// Ignore the finally entry if control is not jumping to a
                    // location outside the try/catch block.
                    o = null);
                    var i = o ? o.completion : {};
                    return i.type = t, i.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, 
                    L) : this.complete(i);
                },
                complete: function(t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, 
                    this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), 
                    L;
                },
                finish: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var r = this.tryEntries[e];
                        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), h(r), L;
                    }
                },
                catch: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var r = this.tryEntries[e];
                        if (r.tryLoc === t) {
                            var n = r.completion;
                            if ("throw" === n.type) {
                                var o = n.arg;
                                h(r);
                            }
                            return o;
                        }
                    }
                    // The context.catch method must only be called with a location
                    // argument that corresponds to a known catch block.
                    throw new Error("illegal catch attempt");
                },
                delegateYield: function(t, e, r) {
                    // Deliberately forget the last sent value so that we don't
                    // accidentally pass it on to the delegate.
                    return this.delegate = {
                        iterator: y(t),
                        resultName: e,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = p), L;
                }
            };
        }(// Among the various tricks for obtaining a reference to the global
        // object, this seems to be the most reliable technique that does not
        // use indirect eval (which violates Content Security Policy).
        "object" === (void 0 === H ? "undefined" : G(H)) ? H : "object" === ("undefined" == typeof window ? "undefined" : G(window)) ? window : "object" === ("undefined" == typeof self ? "undefined" : G(self)) ? self : H);
    }), 16), z = function() {
        function t() {
            n(this, t), this.seed = Date.now(), this.registry = [];
        }
        return C(t, [ {
            key: "get",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now(), r = "Symbol(" + t + ")" + (this.seed + this.registry.length).toString(M);
                return this.registry.push([ r, "" + t + e ]), r;
            }
        }, {
            key: "for",
            value: function(t) {
                if (i(t)) {
                    for (var e = this.registry.length, r = 0; r < e; r += 1) {
                        var n = this.registry[r];
                        if (t === n[1]) return n[0];
                    }
                    return this.get(t, "");
                }
                throw new TypeError("Symbol.for was called with non-string: " + t);
            }
        }, {
            key: "keyFor",
            value: function(t) {
                for (var e = this.registry.length, r = 0; r < e; r += 1) {
                    var n = this.registry[r];
                    if (t === n[0]) return n[1];
                }
            }
        }, {
            key: "Symbol",
            get: function() {
                function t(t, e) {
                    Object.defineProperty(n, t, {
                        value: e
                    });
                }
                function e(e) {
                    t(e, n(e));
                }
                var r = this, n = function(t) {
                    return r.get(t);
                };
                return e("iterator"), e("match"), e("replace"), e("search"), e("split"), e("hasInstance"), 
                e("isConcatSpreadable"), e("unscopables"), e("species"), e("toPrimitive"), e("toStringTag"), 
                t("for", function(t) {
                    return r.for(t);
                }), t("keyFor", function(t) {
                    return r.keyFor(t);
                }), n;
            }
        } ]), t;
    }();
    window.Symbol || (window.Symbol = new z().Symbol);
    var K = Symbol.iterator;
    Array.prototype[K] || (Array.prototype[K] = a);
    var X = 9007199254740991;
    Array.from || (Array.from = l), String.prototype.repeat || (String.prototype.repeat = d), 
    // import postMessage from '../postMessage';
    // import addEventListner from '../dom/addEventListener';
    window.immediateId || (window.immediateId = 0), window.immediateId += 1;
    var Y = window, J = Y.setImmediate, V = void 0;
    V = y, setTimeout(function() {
        // if (postMessage) {
        // 	testImmediate(setImmediatePostMessage, function () {
        // 		if (setImmediateAvailable !== setImmediateNative) {
        // 			setImmediateAvailable = setImmediatePostMessage;
        // 		}
        // 	});
        // }
        J && v(J, function() {
            V = J;
        });
    });
    var Q = function(t) {
        return V(t);
    }, W = 0, Z = 1, $ = 2, tt = 3, et = function t() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        n(this, t), /* eslint-disable no-use-before-define */
        this.promise = new rt(f), /* eslint-enable no-use-before-define */
        this.onResolved = e, this.onRejected = r;
    }, rt = function() {
        function t(e) {
            n(this, t), this.deferreds = [], this.state = W, this.exec(e);
        }
        return C(t, [ {
            key: "is",
            value: function(t) {
                return this.state === t;
            }
        }, {
            key: "exec",
            value: function(t) {
                var e = this, r = !1, n = function(t) {
                    r || (r = !0, e.resolve(t));
                }, o = function(t) {
                    r || (r = !0, e.reject(t));
                };
                try {
                    t(n, o);
                } catch (t) {
                    o(t);
                }
            }
        }, {
            key: "resolve",
            value: function(t) {
                try {
                    if (t === this) throw new TypeError("A promise cannot be resolved with itself");
                    this.value = t, p(t) ? (this.state = tt, this.exec(function(e, r) {
                        t.then(e, r);
                    })) : this.state = Z, this.finish();
                } catch (t) {
                    this.reject(t);
                }
            }
        }, {
            key: "reject",
            value: function(t) {
                this.state = $, this.value = t, this.finish();
            }
        }, {
            key: "finish",
            value: function() {
                var t = this;
                s(this.deferreds, function(e) {
                    t.handle(e);
                }), this.deferreds = null;
            }
        }, {
            key: "handle",
            value: function(t) {
                /* eslint-enable consistent-this */
                for (/* eslint-disable consistent-this */
                var e = this; e.is(tt); ) e = e.value;
                if (e.is(W)) return void c(e.deferreds, t);
                Q(function() {
                    var r = t.promise, n = t.onResolved, o = void 0 === n ? null : n, i = t.onRejected, a = void 0 === i ? null : i, u = e.is(Z), s = u ? o : a;
                    if (null === s) return void (u ? r.resolve(e.value) : r.reject(e.value));
                    var c = void 0;
                    try {
                        c = s(e.value);
                    } catch (t) {
                        return void r.reject(t);
                    }
                    r.resolve(c);
                });
            }
        }, {
            key: "catch",
            value: function(t) {
                return this.then(null, t);
            }
        }, {
            key: "then",
            value: function(t, e) {
                var r = new et(t, e);
                return this.handle(r), r.promise;
            }
        } ], [ {
            key: "resolve",
            value: function(e) {
                return p(e) ? e : new t(function(t) {
                    t(e);
                });
            }
        }, {
            key: "reject",
            value: function(e) {
                return new t(function(t, r) {
                    r(e);
                });
            }
        }, {
            key: "race",
            value: function(e) {
                return new t(function(t, r) {
                    s(e, function(e) {
                        e.then(t, r);
                    });
                });
            }
        }, {
            key: "all",
            value: function(e) {
                return new t(function(t, r) {
                    function n(o, a) {
                        if (p(o)) return void o.then(function(t) {
                            n(t, a);
                        }, r);
                        e[a] = o, 0 === (i -= 1) && t(e);
                    }
                    var o = e.length;
                    if (0 === o) return void t([]);
                    var i = o;
                    s(e, function(t, e) {
                        n(t, e);
                    });
                });
            }
        } ]), t;
    }();
    window.Promise = window.Promise || rt;
    var nt = function() {
        function t(e) {
            var r = this;
            n(this, t), this.clear(), e && s(e, function(t) {
                var e = q(t, 2), n = e[0], o = e[1];
                r.set(n, o);
            });
        }
        return C(t, [ {
            key: "clear",
            value: function() {
                this.data = [];
            }
        }, {
            key: "indexOfKey",
            value: function(t) {
                return m(this.data, function(e) {
                    return q(e, 1)[0] === t;
                });
            }
        }, {
            key: "has",
            value: function(t) {
                return 0 <= this.indexOfKey(t);
            }
        }, {
            key: "set",
            value: function(t, e) {
                var r = this.indexOfKey(t);
                return 0 <= r ? this.data[r][1] = e : c(this.data, [ t, e ]), this;
            }
        }, {
            key: "get",
            value: function(t) {
                var e = w(this.data, function(e) {
                    return q(e, 1)[0] === t;
                });
                if (e) return e[1];
            }
        }, {
            key: "delete",
            value: function(t) {
                var e = this.indexOfKey(t);
                return 0 <= e && (b(this.data, e, 1), !0);
            }
        }, {
            key: "entries",
            value: function() {
                return this.data[Symbol.iterator]();
            }
        }, {
            key: "forEach",
            value: function(t, e) {
                s(this.data, t, e);
            }
        }, {
            key: "keys",
            value: function() {
                var t = this.entries();
                return {
                    next: function() {
                        var e = t.next(), r = e.value, n = e.done;
                        return {
                            value: r && r[0],
                            done: n
                        };
                    }
                };
            }
        }, {
            key: "values",
            value: function() {
                var t = this.entries();
                return {
                    next: function() {
                        var e = t.next(), r = e.value, n = e.done;
                        return {
                            value: r && r[1],
                            done: n
                        };
                    }
                };
            }
        }, {
            key: "size",
            get: function() {
                return this.data.length;
            }
        } ]), t;
    }(), ot = window.Map;
    ot && 1 === new ot([ [ 0, 0 ] ]).size && ot.prototype.forEach || (ot = nt), window.Map = ot, 
    Map.prototype[K] || (Map.prototype[K] = g);
    var it = function() {
        function t(e) {
            var r = this;
            n(this, t), this.clear(), e && s(e, function(t) {
                r.add(t);
            });
        }
        return C(t, [ {
            key: "clear",
            value: function() {
                this.data = [];
            }
        }, {
            key: "indexOf",
            value: function(t) {
                return this.data.indexOf(t);
            }
        }, {
            key: "has",
            value: function(t) {
                return 0 <= this.indexOf(t);
            }
        }, {
            key: "add",
            value: function(t) {
                return this.has(t) || c(this.data, t), this;
            }
        }, {
            key: "delete",
            value: function(t) {
                var e = this.indexOf(t);
                return 0 <= e && b(this.data, e, 1), 0 <= e;
            }
        }, {
            key: "forEach",
            value: function(t, e) {
                var r = this;
                s(this.data, function(n) {
                    t.call(e, n, n, r);
                });
            }
        }, {
            key: "values",
            value: function() {
                return this.data[K]();
            }
        }, {
            key: K,
            value: function() {
                return this.values();
            }
        }, {
            key: "entries",
            value: function() {
                var t = this.values();
                return {
                    next: function() {
                        var e = t.next(), r = e.value, n = e.done;
                        return {
                            value: !n && [ r, r ],
                            done: n
                        };
                    }
                };
            }
        }, {
            key: "size",
            get: function() {
                return this.data.length;
            }
        } ]), t;
    }(), at = window.Set;
    at && 1 === new at([ 0 ]).size && at.prototype.forEach || (at = it), window.Set = at, 
    NodeList.prototype[K] || (NodeList.prototype[K] = k), HTMLCollection.prototype[K] || (HTMLCollection.prototype[K] = x), 
    NamedNodeMap.prototype[K] || (NamedNodeMap.prototype[K] = O);
    var ut = function() {
        function t(e) {
            var r = this;
            n(this, t), this.clear(), e && l(e, function(t) {
                var e = q(t, 2), n = e[0], o = e[1];
                r.append(n, o);
            });
        }
        return C(t, [ {
            key: "clear",
            value: function() {
                this.data = [];
            }
        }, {
            key: "indexOf",
            value: function(t) {
                return m(this.data, function(e) {
                    return q(e, 1)[0] === t;
                });
            }
        }, {
            key: "has",
            value: function(t) {
                return 0 <= this.indexOf(t);
            }
        }, {
            key: "append",
            value: function(t, e) {
                c(this.data, [ t, e ]);
            }
        }, {
            key: "set",
            value: function(t, e) {
                var r = this.indexOf(t);
                r < 0 ? this.append(t, e) : this.data[r][1] = e;
            }
        }, {
            key: "delete",
            value: function(t) {
                this.data = _(this.data, function(e) {
                    return q(e, 1)[0] !== t;
                });
            }
        }, {
            key: "get",
            value: function(t) {
                var e = w(this.data, function(e) {
                    return q(e, 1)[0] === t;
                });
                return e ? e[1] : null;
            }
        }, {
            key: "getAll",
            value: function(t) {
                var e = [];
                return s(this.data, function(r) {
                    var n = q(r, 2), o = n[0], i = n[1];
                    o === t && c(e, i);
                }), e;
            }
        }, {
            key: "toString",
            value: function() {
                return l(this.data, function(t) {
                    var e = q(t, 2), r = e[0], n = e[1];
                    return r + ":" + (void 0 === n ? "" : n);
                }).join(",");
            }
        }, {
            key: "entries",
            value: function() {
                return this.data[K]();
            }
        }, {
            key: "values",
            value: function() {
                var t = this.entries();
                return {
                    next: function() {
                        var e = t.next(), r = e.value, n = e.done;
                        return {
                            value: r && r[1],
                            done: n
                        };
                    }
                };
            }
        }, {
            key: K,
            value: function() {
                return this.entries();
            }
        } ]), t;
    }(), st = "&", ct = "=", ft = function(t) {
        function o(t) {
            return n(this, o), e(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, t ? l(t.replace(/^\?/, "").split(st), function(t) {
                return t.split(ct);
            }) : null));
        }
        return r(o, t), C(o, [ {
            key: "toString",
            value: function() {
                return l(this.data, function(t) {
                    var e = q(t, 2), r = e[0], n = e[1];
                    return r + "=" + (void 0 === n ? "" : n);
                }).join("&");
            }
        } ]), o;
    }(ut), lt = window, ht = lt.URLSearchParams;
    ht && new ht("?a=b").has("a") || (window.URLSearchParams = ft);
    var dt = function(t) {
        function o(t) {
            n(this, o);
            var r = [];
            return t && A(t, function(t, e) {
                c(r, [ e, t ]);
            }), e(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, r));
        }
        return r(o, t), C(o, [ {
            key: "indexOf",
            value: function(t) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "indexOf", this).call(this, j(t));
            }
        }, {
            key: "has",
            value: function(t) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "has", this).call(this, j(t));
            }
        }, {
            key: "append",
            value: function(t, e) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "append", this).call(this, j(t), e);
            }
        }, {
            key: "set",
            value: function(t, e) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "set", this).call(this, j(t), e);
            }
        }, {
            key: "delete",
            value: function(t) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "delete", this).call(this, j(t));
            }
        }, {
            key: "get",
            value: function(t) {
                return N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "getAll", this).call(this, j(t)).join(",");
            }
        }, {
            key: "entries",
            value: function() {
                var t = this, e = N(o.prototype.__proto__ || Object.getPrototypeOf(o.prototype), "entries", this).call(this), r = [];
                return {
                    next: function() {
                        for (;;) {
                            var n = e.next(), o = n.value, i = n.done, a = o && o[0];
                            if (i || r.indexOf(a) < 0) return c(r, a), {
                                value: [ a, t.get(a) ],
                                done: i
                            };
                        }
                    }
                };
            }
        } ]), o;
    }(ut);
    window.Headers || (window.Headers = dt);
    var yt = [ Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, Int8Array, Int16Array, Int32Array, Float32Array, Float64Array ], vt = [ 63, 127, 31, 15, 7, 3, 1 ], pt = 6, wt = vt[0], mt = JSON.parse, bt = function() {
        function t() {
            n(this, t), this.bodyUsed = !1;
        }
        return C(t, [ {
            key: "initBody",
            value: function(t) {
                if (this.bodyInit = t, t) if (i(t)) this.bodyText = t; else if (L(t, Blob)) this.bodyBlob = t; else if (L(t, FormData)) this.bodyFormData = t; else if (L(t, URLSearchParams)) this.bodyText = t.toString(); else if (L(t, DataView)) this.bodyArrayBuffer = U(t.buffer), 
                // IE 10-11 can't handle a DataView body.
                this.bodyInit = new Blob([ this.bodyArrayBuffer ]); else {
                    if (!L(t, ArrayBuffer) && !P(t)) throw new Error("unsupported BodyInit type");
                    this.bodyArrayBuffer = U(t);
                } else this.bodyText = "";
                this.headers.get("content-type") || (i(t) ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this.bodyBlob && this.bodyBlob.type ? this.headers.set("content-type", this.bodyBlob.type) : t instanceof URLSearchParams && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
            }
        }, {
            key: "arrayBuffer",
            value: function() {
                return this.bodyArrayBuffer ? this.isUsed || Promise.resolve(this.bodyArrayBuffer) : this.blob().then(function(t) {
                    return T(t, "ArrayBuffer");
                });
            }
        }, {
            key: "blob",
            value: function() {
                var t = this.isUsed;
                if (t) return t;
                if (this.bodyBlob) return Promise.resolve(this.bodyBlob);
                if (this.bodyArrayBuffer) return Promise.resolve(new Blob([ this.bodyArrayBuffer ]));
                if (this.bodyFormData) throw new Error("could not read FormData body as blob");
                return Promise.resolve(new Blob([ this.bodyText ]));
            }
        }, {
            key: "text",
            value: function() {
                var t = this.isUsed;
                if (t) return t;
                if (this.bodyBlob) return T(this.bodyBlob, "Text");
                if (this.bodyArrayBuffer) return Promise.resolve(B(this.bodyArrayBuffer));
                if (this.bodyFormData) throw new Error("could not read FormData body as text");
                return Promise.resolve(this.bodyText);
            }
        }, {
            key: "formData",
            value: function() {
                return this.text().then(R);
            }
        }, {
            key: "json",
            value: function() {
                return this.text().then(mt);
            }
        }, {
            key: "isUsed",
            get: function() {
                if (this.bodyUsed) return Promise.reject(new TypeError("Already used"));
                this.bodyUsed = !0;
            }
        } ]), t;
    }(), gt = function(t) {
        function o(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            n(this, o);
            var i = r.body, a = e(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this));
            if (t instanceof o ? i = a.inheritFrom(t, i, r) : a.url = "" + t, a.credentials = r.credentials || a.credentials || "omit", 
            !r.headers && a.headers || (a.headers = new dt(r.headers)), a.method = (r.method || a.method || "GET").toUpperCase(), 
            a.mode = r.mode || a.mode || null, a.referrer = null, ("GET" === a.method || "HEAD" === a.method) && i) throw new TypeError("Body not allowed for GET or HEAD requests");
            return a.initBody(i), a;
        }
        return r(o, t), C(o, [ {
            key: "inheritFrom",
            value: function(t, e, r) {
                var n = r.headers;
                if (t.bodyUsed) throw new TypeError("Already read");
                return this.url = t.url, this.credentials = t.credentials, n || (this.headers = new dt(t.headers)), 
                this.method = t.method, this.mode = t.mode, e || null === t.bodyInit || (e = t.bodyInit, 
                t.bodyUsed = !0), e;
            }
        }, {
            key: "clone",
            value: function() {
                return new o(this, {
                    body: this.bodyInit
                });
            }
        } ]), o;
    }(bt), kt = 200, xt = 300, Ot = [ 301, 302, 303, 307, 308 ], _t = function(t) {
        function o(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            n(this, o);
            var i = e(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this));
            return i.type = "default", i.status = "status" in r ? r.status : kt, i.ok = i.status >= kt && i.status < xt, 
            i.statusText = "statusText" in r ? r.statusText : "OK", i.headers = new dt(r.headers), 
            i.url = r.url || "", i.initBody(t), i;
        }
        return r(o, t), C(o, [ {
            key: "clone",
            value: function() {
                return new o(this.bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new dt(this.headers),
                    url: this.url
                });
            }
        }, {
            key: "redirect",
            value: function(t, e) {
                if (Ot.indexOf(e) < 0) throw new RangeError("Invalid status code");
                return new o(null, {
                    status: e,
                    headers: {
                        location: t
                    }
                });
            }
        } ], [ {
            key: "error",
            value: function() {
                var t = new o(null, {
                    status: 0,
                    statusText: ""
                });
                return t.type = "error", t;
            }
        } ]), o;
    }(bt);
    // if (!window.fetch) {
    // 	window.fetch = j0Fetch;
    // }
    window.fetch = D, window.Body || (window.Body = bt), window.Response || (window.Response = _t), 
    window.Request || (window.Request = gt), window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
        return setTimeout(function() {
            t(Date.now());
        }, 30);
    }, window.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || function(t) {
        return clearTimeout(t);
    }, window.global = window;
}();